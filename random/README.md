
# [乱数を使ったプログラム](https://kaityo256.github.io/python_zero/random/)

* モンテカルロ法
* 疑似乱数
* モンティ・ホール問題
* パーコレーション
* 余談：確率の難しさ
* 余談：疑似乱数とゲーム

## モンテカルロ法

大勢で「じゃんけん」をしたとき、なかなか勝負が決まらない経験をしたことがないだろうか。じゃんけんに参加する人数が増えるほど、「あいこ」の確率が増え、勝負が決まらなくなる気がする。それでは、$N$人が参加するじゃんけんで、「あいこ」になる確率はいったいどれくらいだろうか？

もちろんこれは理論的に計算できる。しかし、特に確率の問題は、計算した答えが合っているかどうか不安になるだろう。そこで、実際に計算機でシミュレーションして「答え合わせ」をしたくなる。というわけで、このじゃんけん問題をプログラムで表現することを考えてみよう。

じゃんけんで「あいこ」になるのは、みんなのだした手がすべて同じ(1種類)か、全て異なる(3種類)かなので、出した手の種類の数を数えれば良い。したがって、こんなプログラムになるだろう。

1. $N$人が「グー」「チョキ」「パー」のどれかを1/3の確率で選ぶ
2. 選んだ$N$個の「手」が、1種類か3種類の時には「あいこ」
3. 1と2を繰り返して確率を求める

ここで問題となるのは1.の「$N$人が「グー」「チョキ」「パー」のどれかを1/3の確率で選ぶ」というところだ。そのためには「グー」「チョキ」「パー」から「ランダム」にどれかを選ぶ、という処理が必要になる。このようなランダムな事象を扱うために、Pythonには`random`というライブラリが用意されている。今回のケースでは、リストの要素をランダムに選ぶ`random.choice`という関数を使えば簡単に実装できる。

例えば、「グー」「チョキ」「パー」をそれぞれ`G`、`C`、`P`で表現しよう。この三要素を持つリストは`['G','C','P']`で表現できる。そして、

```py
import random
random.choice(['G','C','P'])
```

とすると、実行するたびに`G`、`C`、`P`のどれかがランダムに選ばれる。先ほどの`random.choice`とリストの内包表記を使うと、例えば10人のじゃんけんの手のリストは、

```py
N = 10
[random.choice(['G','C','P']) for _ in range(N)]
```

で作ることができる。実行結果は例えば

```txt
['G', 'G', 'G', 'G', 'P', 'G', 'C', 'G', 'C', 'P']
```

などとなる(実行するたびに異なる)。

さて、`set`という関数を使うと、リストのうち重複する要素を削除することができる。

```py
set(['G', 'G', 'G', 'G', 'P', 'G', 'C', 'G', 'C', 'P']) #=> {'C', 'G', 'P'}
```

![じゃんけんの勝負判定](fig/janken.png)

こうして、$N$人の「手」のリストを作り、重複する要素を削除すれば、それが「手」の種類なので、それが1種類なのか3種類なのか判定すれば良い。以上を愚直にコードに落とすとこんな感じになるだろう。

```py
import random

trial = 100000
N = 6
aiko = 0
for _ in range(trial):
    a = [random.choice(['G', 'C', 'P']) for _ in range(N)]
    if len(set(a)) in (1, 3):
        aiko += 1
print(aiko/trial)
```

6人で100000回じゃんけんをさせて、あいこになった数をカウントし、その確率を求めるものだ。実行結果は、例えば以下のようになるだろう。

```txt
0.74684
```

厳密解は

$$
1 - \frac{2^N - 2}{3^{N-1}} = \frac{181}{243} \sim 0.745
$$

なので、「合ってそうだな」ということがわかるだろう(興味がある人はこの厳密解を導出せよ)。

このように、プログラムで確率的な事象をシミュレーションして、何らかの値を求める手法を **モンテカルロ法 (Monte Carlo Method)** と呼ぶ。ここではモンテカルロ法を厳密な答えがわかっている場合の確率の確認に用いたが、複雑な事象(例えば社会現象)のシミュレーションや、数値積分などに用いることができる。今回はPythonでモンテカルロ法を実装してみよう。

## 疑似乱数

### 疑似乱数とは

いま、サイコロを何度もふって、例えば出た目の数の並びが「4, 6, 1, 2, 3, 1, 1, 2, 4, 4」だったとしよう。ここまでの情報で、「次の出目」を予想できるだろうか？「普通」に考えると「4や1が続いてて、まだ5が出ていないからそろそろ5が出るかな」などと考えたくなるが、もしいま使っているのが理想的なサイコロであるならば、次も1から6まで等確率で出現するため、どれが出やすいとか、どれが出にくいなどと予想することはできない。このように「これまでの数列の知識から、次の数を予想できない」ような数列を **乱数列** と呼び、乱数列のそれぞれの要素を **乱数(Random Number)** と呼ぶ。

計算機において乱数が必要になることは多い。例えばゲームで低確率で出る「会心の一撃」や「痛恨の一撃」を表現するのに乱数が必要だ。レアなモンスターを出現させるのも乱数が必要である。しかし、現在の計算機は決定論的に動作するため「真の乱数列」を表現するのは難しい。「真の乱数列」とは、先程定義した通り「これまでの数列から、次の数字が予想できない」ような数列のことであるのに対し、計算機で実現される乱数は **疑似乱数(Pseudorandom number)** と呼ばれる。疑似乱数列は乱数列のように見えるが、実は規則性があり、これまでの乱数から次の乱数が予想できてしまうものだ。疑似乱数列を作る方法には、線形合同法やM系列など様々な方法があるが、現在広く使われているのはメルセンヌ・ツイスター法という手法である。多くのプログラム言語が乱数生成のデフォルトアルゴリズムとしてメルセンヌ・ツイスター法を採用している。本講義では擬似乱数生成アルゴリズムについては触れないが、興味がある人は調べてみると良い。また、原子核崩壊などの物理現象を用いることで「真の乱数」を作るデバイスも発売されている。

### Pythonにおける疑似乱数

Pythonには擬似乱数用に`random`というライブラリが用意されており、様々な関数が用意されている。そのうちよく使うものの使い方を紹介しておこう。

#### `random.randint`

例えば1から6までの整数の乱数が欲しければ、`random.randint`が使える。

以下のコードを書いて実行してみよう。これは6面サイコロを10回ふることをシミュレーションしたものだ。

```py
import random

for _ in range(10):
    print(random.randint(1,6))
```

これは実行するたびに異なる結果が得られる。例えば以下のような結果が得られる。

```txt
4
3
1
4
1
4
4
4
1
6
```

#### `random.seed`

先程のコードは実行するたびに異なる結果が得られた。しかし、以下のようにすると、何度実行しても同じ乱数列が得られる。

```py
import random

random.seed(1)
for _ in range(10):
    print(random.randint(1,6))
```

これは`random.seed`により乱数の「種」を固定したためだ。計算機は、漸化式により乱数列を作ることが多い。漸化式は、生成した乱数を入力として次の乱数を作る方法だが、その一番最初に与える値を乱数の「種(seed)」と呼ぶ。同じ種からは同じ乱数列が生まれる。これでは乱数としては不都合であるので、「現在時刻」等を乱数の種とすることが多い。こうすると実行するたびに異なる乱数列が得られる。しかし、主にデバッグ目的などで、毎回同じ乱数の種を与えたいときもあり、`random.seed`は、そのような場合に用いる。

#### `random.random`

`random.randint`を用いると整数の乱数列が得られたが、実数の乱数列が欲しければ`random.random`を用いる。これは0から1未満のランダムな実数を返してくれる関数だ。

```py
import random
for _ in range(10):
    print(random.random())
```

例えば実行結果はこんな感じになる。

```txt
0.2293093032885165
0.7225401496925509
0.4118307989719816
0.4352123667218194
0.5182296930788952
0.6598049756657662
0.5928754652967204
0.35716459244689625
0.7115734931703437
0.9442876247500515
```

出現する可能性のある乱数の、それぞれの出現確率がすべて等しい場合、その乱数を **一様乱数** と呼ぶ。ある分布に従うような非一様な乱数が生成できると便利な場合もあるが、本講義では一様乱数のみを扱うことにする。なお、確率をきちんと定義、議論するのは面倒なので、ここでは確率についてかなりいい加減な定義を使っていることを了解されたい。

#### `random.choice`

リストが与えられた時、そのリストの要素をランダムに選びたいことがある。これはリストのサイズと`random.randint`を使って書くこともできるが、最初に紹介した`random.choice`という関数が便利なのでそれを利用しよう。

```py
import random
a = ["A","B","C"]
for _ in range(10):
    print(random.choice(a))
```

例えば実行結果は以下のようになる。

```txt
A
A
B
A
C
B
C
C
C
B
```

ちなみに`random.randint`を使うとこのようになる。

```py
import random
a = ["A","B","C"]
for _ in range(10):
    i = random.randint(0,len(a)-1)
    print(a[i])
```

0から`len(a)-1`の範囲の乱数`i`を生成し、それをインデックスとして`a[i]`にアクセスしている。

## モンテカルロ法による数値積分

今回の講義では詳細は扱わないが、モンテカルロ法は数値積分にも用いられるので、簡単に紹介しておこう。モンテカルロ法による数値積分で有名なのは、円周率の計算であろう。ダーツの要領でランダムに「矢」を投げ、当たった数で円周率を推定する方法である。以下は$n$回ダーツを投げて円周率を推定するプログラムである。

```py
from random import random

def calc_pi(n):
    r = 0
    for _ in range(n):
        x = random()
        y = random()
        if x**2 + y**2 < 1.0:
            r += 1
    return 4 * r / n

calc_pi(10000)
```

これは、実は以下のような二次元の数値積分をしていることと等価である。

$$
\pi \sim 4 \int_0^1 \int_0^1 \Theta(1-x^2-y^2) dx dy
$$

ただし$\Theta(x)$はステップ関数で、$x\geq 1$で1、そうでない場合は0となる関数である。この積分はこれは単位円の1/4の面積に対応するので、それを4倍すると円周率になるのは当たり前のように見えるが、実際の手続きとしては、0から1の一様乱数二つの二乗和が1を超えるかどうかを判定しているだけなので、それで円周率という超越数を計算できるのは面白い。

このアルゴリズムは簡単で、少ない試行回数でそこそこの精度が出るが、収束が遅いために円周率を高精度に求めるのには向かない。現在、数値積分目的には単純なモンテカルロ法はほとんど使われておらず、モンテカルロ法というと、ほぼ「マルコフ連鎖モンテカルロ法 (Markov-chain Monte Calro method, MCMC)」のことを指す。ここでは詳細については触れないが、ナイーブなモンテカルロ法に比べてマルコフ連鎖モンテカルロ法は極めて収束が早いため、「ダーツによる円周率」の問題だけを見て「モンテカルロ法は遅い」という印象は持たないで欲しい。

## モンティ・ホール問題

さて、モンテカルロ法により、確率的な事象のシミュレーションをして、何かの確率を求めてみよう。その題材として「モンティ・ホール問題」を取りあげる。モンティ・ホール問題とは、アメリカの番組の中で行われた、あるゲームに由来する。そのゲームのルールとはこういうものである。

* 三つの箱が用意され、その中に一つだけ商品が入っており、残りの二つは空である。
* プレイヤーは、そのうちの一つを選ぶ
* 司会者は、選ばれなかった二つの箱の中身を確認し、空であるほうの箱を開ける
* その上で司会者はプレイヤーに「選んだ箱を変えてよい」という
* さて、プレイヤーは選んだ箱を変えたほうが得だろうか？それとも確率は変わらないだろうか？

![mh1.png](fig/mh1.png)
![mh2.png](fig/mh2.png)

この問題は有名なので、答えを知っている人も多いだろう。しかし、ここは答えを全く知らないとして、シミュレーションをしよう。

まずは、司会者が選ばれなかった箱のうち一つを開け、「選んだ箱を変えてよい」と言った時に「最初に選んだ箱を変えない」戦略を考えよう。
これをKeep派と呼ぶ。Keep派は司会者の影響を受けないので、シミュレーションは簡単だ。

1. 三つの箱を用意し、どれが正解かをランダムに決める
2. プレイヤーは、三つの箱をランダムに選ぶ
3. 正解の箱と、プレイヤーが選んだ箱が一致したら、「一致した回数」を+1する。

以上、1〜3を何度も繰り返して、「一致した回数」を「試行回数」で割ったものがKeep派の正解確率である。

次に、司会者が「選んだ箱を変えて良い」と言われたら「必ず変える」戦略を考えよう。これをChange派と呼ぶ。Change派のシミュレーションは以下のようになるだろう。

1. 三つの箱を用意し、どれが正解かをランダムに決める
2. プレイヤーは、三つの箱をランダムに選ぶ
3. 司会者は、残った箱のうち「正解で無い方」をランダムに選ぶ
4. プレイヤーは「司会者が開けなかった方」を選び、それを最終決定とする

以上、1〜4を何度も繰り返し、「一致した回数」を「試行回数」で割ったものがChange派の正解確率である。

## パーコレーション

乱数を使うプログラムのもう一つの例としてパーコレーションを取り上げる。

![percolation.png](fig/percolation.png)

札幌の市街のような、碁盤の目のような道路があるとしよう。ところがある日、大雪が降って、道がところどころ通行止めになってしまった。いま、道が通行可能な確率をpとしよう。通行可能な道だけを通って「こっち側」から「向こう側」に渡れる確率(Crossing Probability)$C$を知りたい。渡れる確率$C$は確率pの関数となる。当然、$p$が小さければ渡れる確率は低く、大きければ渡れる確率は高くなると思われるが、どんな関数になるか想像できるだろうか？

いま、正方格子の「辺」を通ることを考えたが、これはボンド・パーコレーションと呼ばれるモデルとなる。同様に、正方形に区切られたパネルがあるとする。その区画が、確率$p$で通行可能、$1-p$で通行不可だとしよう。通行人は、かつ上下左右につながった、通行可能なパネルのみ渡ることができる。「こちら側」から「向こう側」にわたることができる確率は、pに対してどう振る舞うだろうか？こちらはサイト・パーコレーションと呼ばれるモデルである。

この「向こう岸に渡れる確率」だが、十分大きなシステムでは、「$p$がある臨界値$p_c$未満ではほぼ確実に渡ることができず、$p_c$より大きければほぼ確実に渡ることができる」という振る舞いを見せる。つまり、系の振る舞いがパラメータのある一点を境に大きく変化する。このように、あるパラメータを変化させていったときに、ある点で系の性質が大きく変化することを **相転移(Phase Transigion)** と呼ぶ。パーコレーションは、相転移を示す最も簡単なモデルのひとつだ。身近な相転移としては、水の沸騰などが挙げられる。水を一気圧の条件で温度を徐々に挙げていくと、摂氏100度で沸騰し、水蒸気になる。水も水蒸気も水分子から構成されており、それは全く変化していない。しかし、水分子の集団としての振る舞いが大きく変化するのである。0度以下に冷やすと凍るのも相転移である。

# 乱数を使ったプログラム：課題

## 課題1：モンティ・ホール問題

モンティ・ホール問題において、Keep派、Change派それぞれの「正解確率」を計算し、どちらが得かを考えてみよう。

### 課題1-1：Keep派

まずはKeep派のシミュレーションをしよう。

#### 1. ライブラリのインポート

何はともあれ、まずはライブラリのインポートである。後で使うライブラリをまとめてインポートしておこう。

```py
from random import choice, seed
from copy import copy
```

#### 2. Keep派のアルゴリズム`keep`を実装

箱の中身のリストを渡されたときに、答えの箱と、プレイヤーの選ぶ箱をランダムに選び、一致するかどうかを返す関数`keep`を作ってみる。二つ目のセルに以下を入力せよ。

```py
def keep(boxes):
    answer = choice(boxes)
    player_choice = choice(boxes)
    return answer == player_choice
```

入力・実行したら、適当な箱リストを与えて`keep`を呼んでみよう。三つ目のセルに以下を入力し、実行せよ。

```py
seed(1)
boxes = ["A","B","C"]
for _ in range(10):
    print(keep(boxes))
```

このような結果が得られるはずである。

```sh
False
False
False
True
False
True
False
True
False
False
```

正解の箱とプレイヤーの選んだ箱が一致したら`True`、そうでなければ`False`と表示されている。動作確認が済んだら三つ目のセルは消して良い。

#### 3. 正解確率を計算する関数`calc_prob`の実装

次に、三番目のセルに、正解確率を計算する関数`calc_prob`を実装しよう。

```py
def calc_prob(n):
    seed(1)
    boxes = ["A","B","C"]
    k = 0
    for _ in range(n):
        if keep(boxes):
            k += 1
    print("Keep  : " + str(k/n))
```

#### 4. Keep派の正解確率の計算

四番目のセルに以下を入力して実行せよ。

```py
calc_prob(1000)
```

Keep派の正解確率が出てきたはずである。だいたいどれくらいの値になったか？

### 課題1-2：Change派

さて、先ほどとは逆に「選んだ箱を変えてよい」と言われた時に、必ず箱を変える戦略を考えよう。これをChange派と呼ぶ。

#### 5. 関数`change`の実装

五番目のセルに、`change`を実装しよう。箱のリストを受け取り、正解と、プレイヤーが最初に選ぶ箱を決めるところまでは同じである。
さて、次に「司会者が開ける箱」を考える必要がある。司会者が開けるのは、プレイヤーが選んだ箱であっても、正解の箱あってもならない。
そこで、「箱リストから、プレイヤーが選んだ箱と、正解の箱を除外したリストを作り、そこからランダムに選ぶ」ことを考える。

TODO: 以下をfilterではなくremoveとif inで書き直す課題とする。host_choiceを作らせる

```py
def change(boxes):
    answer = choice(boxes)
    player_choice = choice(boxes)
    boxes2 = list(filter(lambda x: x not in (player_choice, answer), boxes))
    print(answer, player_choice, boxes2)
```

6番目のセルにテストコードを書いて実行しよう。

```py
boxes = ["A","B","C"]
for _ in range(10):
  change(boxes)
```

種を固定していないため、実行するたびに異なるが、例えば以下のような結果が得られるはずだ。

```py
A A ['B', 'C']
C A ['B']
B A ['C']
B A ['C']
B C ['A']
C B ['A']
A A ['B', 'C']
A C ['B']
C A ['B']
B B ['A', 'C']
```

最初が正解の箱、二番目がプレイヤーの選んだ箱、三番目のリストが、司会者が開ける可能性のある箱である。司会者が開ける箱は、プレイヤーが選んだ箱でも、正解の箱でもないことに注意しよう。さて、`boxes2`から`choice`すれば、司会者が開ける箱が得られる。それを`chair_choice`としよう。
プレイヤーは、全部の箱のうち、「最初に自分が選んだ箱」でも、「司会者が開けた箱」でもないものを選ぶ。今回はそれは一つに決まるが、後の拡張のために。その候補リストを作ろう。先ほどの「司会者が開ける可能性の箱リスト」と同様に作ることができる。`change`を以下のように書き換えよ。

```py
def change(boxes):
    answer = choice(boxes)
    player_choice = choice(boxes)
    boxes2 = list(filter(lambda x: x not in (player_choice, answer), boxes))
    chair_choice = choice(boxes2)
    boxes3 = list(filter(lambda x: x not in (player_choice, chair_choice), boxes))
    print(player_choice, chair_choice, boxes3)
```

実行してみよう。

```sh
C A ['B']
B A ['C']
C A ['B']
B A ['C']
C A ['B']
B C ['A']
A B ['C']
A B ['C']
C A ['B']
B C ['A']
```

最初がプレイヤーが選んだ箱、次が司会者が開けた箱、最後が「プレイヤーが選択を変える箱の候補リスト」である。
それぞれに重複がないことを確認せよ。この「候補リスト」から`choice`したものがプレイヤーの最終選択である。

```py
def change(boxes):
    answer = choice(boxes)
    player_choice = choice(boxes)
    boxes2 = list(filter(lambda x: x not in (player_choice, answer), boxes))
    chair_choice = choice(boxes2)
    boxes3 = list(filter(lambda x: x not in (player_choice, chair_choice), boxes))
    player_choice = choice(boxes3)
    return player_choice == answer
```

先ほど作成した`calc_prob`を、Change派の確率も計算するように修正しよう。

```py
def calc_prob(n):
    seed(1)
    boxes = ["A","B","C"]
    k = 0
    c = 0
    for _ in range(n):
        if keep(boxes):
            k += 1
        if change(boxes):
            c += 1
    print("Keep  : " + str(k/n))
    print("Change: " + str(c/n))
```

以下を実行してみよ。

```py
calc_prob(10000)
```

Keep派とChange派、どちらが正解確率が高いだろうか？

## 課題2：パーコレーション

乱数を使ったシミュレーションの例として、パーコレーションを考えてみよう。新しいノートブックを開き、`percolation.ipynb`として保存せよ。

### 課題2-1：クラスタの可視化

#### 1. ライブラリのインポート

最初のセルでは、いつもどおりライブラリのインポートをする。

```py
import random
from PIL import Image, ImageDraw
import IPython
```

#### 2. `find`関数

2つ目のセルで、自分が所属するクラスタ番号を調べる`find`関数を実装しよう。自分の番号が親の番号と一致する`i = parent[i]`まで、親をたどっていくプログラムである。

```py
def find(i, parent):
    while i != parent[i]:
        i = parent[i]
    return i
```

#### 3.`union`関数

3つ目のセルで、二つのサイトを確率的につなぐ`union`関数を実装しよう。サイト`i`とサイト`j`のクラスター番号を`find`で取得し、サイト`j`の所属するクラスタの親をサイト`i`が所属するクラスタにすることで、二つのサイトをつなぐことができる。

```py
def union(i, j, parent):
    i = find(i, parent)
    j = find(j, parent)
    parent[j] = i
```

#### 4. 状態の作成

`find`と`union`の実装ができたら、サイトの状態を作るのは難しくない。4つ目のセルに以下を入力せよ。

```py
def make_conf(L, p):
    parent = [i for i in range(L * L)]
    for iy in range(L-1):
        for ix in range(L-1):
            i = ix + iy * L
            j = ix+1 + iy * L
            if random.random() < p:
                union(i, j, parent)
            j = ix + (iy+1) * L
            if random.random() < p:
                union(i, j, parent)
    return parent
```

最初に「親」の情報`parent`を作成しておく。最初はすべて`parent[i] = i`、つまり自分の親が自分自身である状態にしておく。そして、右端と下端を除く全てのサイトについて「右」と「下」のサイトと確率的につなぐ処理を記述している。`if random.random() < p:`というセンテンスは「確率pでif文の中身が実行される」という処理で、確率的な処理の基本となるので覚えておくと良い。

#### 5. 状態の可視化関数

5つ目のセルに、サイトの親の情報を受け取って可視化する関数`show_image`を実装しよう。

```py
def show_image(parent, L):
    size = 512
    s = size // L
    im = Image.new("RGB", (size, size), (255, 255, 255))
    colors = []
    for _ in range(L*L):
        r = random.randint(0, 255)
        g = random.randint(0, 255)
        b = random.randint(0, 255)
        colors.append((r, g, b))
    draw = ImageDraw.Draw(im)
    for iy in range(L):
        for ix in range(L):
            i = ix + iy * L
            i = find(i, parent)
            c = colors[i]
            draw.rectangle((ix*s, iy*s, ix*s+s, iy*s+s), fill=c)
    im.save("test.png")
```

あらかじめ、ランダムにクラスター番号と色の対応表`colors`を作っておき、それぞれのサイトのクラスター番号で色を塗ることで「同じクラスターは同じ色で塗る」を実現している。

#### 6. シミュレーション

では、早速シミュレーションをしてみよう。まずは通行確率pが0、つまり全ての区間が孤立している状態を可視化してみる。6つ目のセルに以下を入力、実行せよ。

```py
L = 256
p = 0.0
sites = make_conf(L, p)
show_image(sites, L)
IPython.display.Image("test.png")
```

ここまで正しく実装されていれば、ノイズのような画面が表示されたはずである。

では、次に`p = 0.4`を試してみよ。お互いに通行可能な区間が同じ色で表示されるため、同じ色で塗られた領域(クラスター)が出現したはずである。

`p=0.49`と、`p=0.51`をそれぞれ何度か試し、気づいたことを報告せよ。同じ色のクラスターだけをたどって「下から上」へ到達できるだろうか？

## 余談：確率の難しさ

確率が絡んだ問題は、時として直観と合わない結果を生む。そんな問題は(厳密にはパラドックスではないが)パラドックスと呼ばれる。有名なのは「誕生日のパラドックス」であろう。今、うるう年は考えず、一年が365日だとしよう。また、誕生日は一様であるとする。さて、30人いるクラスで、誕生日が同じペアが存在する確率はどのくらいだろうか？
ちょっと想像してから、こんなコードを書いて確認してみよう。

```py
def p(n):
    r = 1.0
    for i in range(n):
        r *= (365-i)/365
    return 1.0 - r

p(30)
```

思ったより大きかったのではないだろうか？逆に、直観より確率が小さいことを「悪用」する例としては「コンプガチャ」と呼ばれる景品がある。これは「絵合わせ」もしくは「カード合わせ」と呼ばれる古典的なギャンブルであり、

* 複数種類の絵柄のあるカードがあり、お金を払うとそのどれかがランダムで手に入る
* 複数の絵柄をすべて揃えたら、景品が当たる

というものである。例えば、カードが10種類あり、一枚100円とする。全種類揃えるのに必要な経費の期待値はどのくらいか、すぐにわかるだろうか？やはり少し想像してから計算してみよう。

```py
def p(n):
    r = 0.0
    for i in range(n):
        r += n/(i+1)
    return r

p(10)
```

「10種類ある絵柄が等確率で当たり、10種類揃えたら景品を渡す」という文面に嘘がなく、確率操作などをせずその通りに実施するとしても、これは違法となる。なぜ違法とすべきなのか、考えてみると面白いであろう。

モンティ・ホール問題でも、直観と乖離した結果に多くの人が騙された。間違った人々の中には数学者もいて、新聞に意見を投書して紹介され、のちに恥をかいたようだ。現在はネット社会であり、何か肩書を持った人が間違ったことを言うと多くの人の目に触れ、昔より炎上しやすい。この問題が教えてくれる本当の教訓は「何か発言するときは気を付けよう」ということかもしれない。

### 余談：疑似乱数とゲーム

ゲームには乱数がつきものである。RPGなどでは、どの敵が現れるか、攻撃が成功するか、失敗するかなど、全てランダムに決めたい。「はぐれメタル」などのレアなモンスターに、「会心の一撃」などのレアな攻撃が当たって興奮した、などの経験があるだろう。しかし、ゲームは計算機であり、計算機における乱数は疑似乱数である以上、理論上乱数は予想可能である。例えばあるゲームでは「ゲーム機が稼働開始してからの時間」を乱数の種に使っていたため、レアな敵が出たときにセーブしてリセットすると、全く同じ敵が現れてしまう、という仕様(バグ？)があった。これを利用してレアな敵を狩りまくり、貴重なアイテムを多数手に入れるという「技」があった。また、動画などを見ていて「TAS」という言葉を見かけたことはないだろうか。これは「Tool Assisted Speedrun」の略で、もともとゲームをエミュレータ上で実行し、理論上可能だが人間には不可能な速度でクリアすることを指したが、そのうちタイムアタック以外についてもTASと呼ばれるようになった。例えばTASによるRPGのタイムアタック動画では、「はぐれメタル」ばかり出て、それに「会心の一撃」ばかりあたるようなことが起きる。次にこういう動画を見るとき、一見無駄な動作が混ざっていないか注意してみてみよう。これは「乱数調整」といわれる手法である。例えばサイコロで「6」が出たら「会心の一撃」が出ることがわかっており、かつこれからのサイコロの目が「2,4,1,3,6」という順番であることもわかっている場合、戦闘の自分の番で「6」が出るように、事前にサイコロを振るのである。

疑似乱数とゲームといえば、面白いのが「質の悪い乱数」によるバグだろう。「カルドセプトサーガ」というXbox360のゲームがある。カルドセプトは、モノポリーのようなボードゲームに、マジック・ザ・ギャザリングのようなカードによるクリーチャー同士の戦いを組み合わせたようなゲームで、その戦略性から人気のあるシリーズであった。しかし「カルドセプトサーガ」は、サイコロの出目が非常に偏っており、例えば偶数と奇数が交互に出る問題があった。このようなサイコロゲームで、次の目が予想できるというのは致命的である。この問題が発覚したのち、ネットで「サイコロくらい簡単だろ」と「正しい」サンプルプログラムを書いた人がいたが、それもことごとくカルドセプトサーガと同じ過ちを犯していたそうである。「ネットに書き込む前に一呼吸」を意識しよう。
