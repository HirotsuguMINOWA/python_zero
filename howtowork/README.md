
# [Pythonはどうやって動くのか](https://kaityo256.github.io/python_zero/howtowork/)

* コンピュータはどうやって動くのか
* 抽象構文木とバイトコードについて
* 仮想マシン
* 逆ポーランド記法電卓

## コンピュータはどうやって動くのか

車を運転していない人でも、車はガソリンという可燃性の液体を燃料とし、それを噴射して点火、爆発させてピストンを動かし、そのピストンの運動を回転運動に変換してタイヤに伝えて動いている、ということはぼんやりと知っていることだろう。この知識は、車を運転するときにはあまり必要ない。実際、車の運転をする際にエンジンやトランスミッションの仕組みを意識することは(よほど車好きでない限り)稀であろう。しかしそれでも、車の仕組みは簡単に知っておくべきだと思う。冷蔵庫や電子レンジ、これらの家電は、その動作原理を知らずとも使うことは可能だし、おぼろげに原理を知っているからといってあまり役に立つ気はしないが、やはりざっくりとは知っておくべきだと思う。それが教養というものだ。コンピュータの動作についても同様である。

これまで、ブラウザ上でプログラムを入力し、実行させ、その結果を表示させてきた。Pythonのプログラムはクラウド上で実行されたが、そのブラウザを実行しているのは皆さんの目の前にあるのはコンピュータである。コンピュータとはcomputeするもの、つまり計算機であり、何かしら計算してその結果を表示することを繰り返す機械である。では、そもそもプログラムとはどうやって動いているのだろうか？せっかくプログラミングを覚えるのだから、計算機がどういう仕組みで動いているのか知っておいた方が良いだろう。なお、私は古い人間なので、コンピュータのことをどうしても「計算機」と呼んでしまう。以後、パソコンやCPUなどを指して「計算機」と呼ぶのでそのつもりでいて欲しい。

いま、目の前にある計算機は、ディスプレイ(表示装置)、キーボードやマウス(入力装置)、CPU(中央演算処理装置)、メモリ(記憶装置)などから構成されている。ディスクなどのストレージやネットワークなどの通信装置については今は忘れよう。このうちCPUがもっとも重要な装置であるが、やっていることは非常に単純で、

* メモリから命令とデータを取ってくる
* 命令を解釈し、データを演算器に投げる
* 演算器から返ってきた結果をメモリに書き戻す

ということをひたすら繰り返しているに過ぎない。「命令」も一種のデータであり、メモリに置いてあることに注意しよう。演算器というのは、文字通り演算する機械である。例えば足し算をしたければ加算器を、掛け算をしたければ乗算器が必要になる。また、整数演算と浮動小数点演算は全く異なる演算器を用いる。

さて、計算機が解釈できるのは数字だけである。したがって、人間が計算機に命令するためには、機械語(マシン語)と呼ばれる数字の羅列を使う必要がある。コンピュータとは計算機であり、計算とはデータに四則演算などの演算をすることである。したがって、計算機に何か計算させたければ「何を(データ)」「どうするか(命令)」がセットである必要があることがわかるだろう。機械語というと難しそうだが、結局のところ「何を」「どうするか」を羅列しているに過ぎない。

![機械語の実行](fig/opcode.png)

例えば一桁の整数を二つ受け取って四則演算をする計算機があったとしよう。四則演算をするので、演算は加算、減算、乗算、除算の四種類である。なのでそれぞれに0,1,2,3の数字を割り当てよう。四則演算をするには、整数が二つ必要だ。その数字も並べよう。例えば「034」という数字列は「3+4」を、「185」は「8-5」を表す。計算機は、メモリから三つの数字をとってきて、最初の数字を見て「どの演算器に投げるか」を決める(命令を最初に置いたのはそのためだ)。そして続く二つのデータを演算器に投げる。かなり単純化されているが、これが機械語である。このように、「何をするか」を表す部分をオペコード(operation code, opcode)、「データ」を表す部分をオペランド(operand、被演算子)と呼ぶ。

## プログラム言語とコンパイラ

さて、計算機が解釈できるのは機械語だけである。機械語は難しくはないが、「足し算は0で・・・」と覚えるのは面倒だ。そこで「034」という数字の羅列の代わりに「ADD 3,4」という書き方をしよう。これを「034」に変換するのは簡単だし、人間が見て「3と4を足すんだな」とわかりやすい。このように機械語と一対一対応する言語を「アセンブリ言語(Assembly Language)」と呼ぶ。しかし、アセンブリ言語でもまだ面倒だ。もっと、人間にわかりやすい形式、先ほどの例なら「3+4」と書いて、それを計算機が理解できる形式に変換したい、と思うのは自然であろう。その「人間が理解できる形式」がプログラム言語と呼ばれるものである。

プログラム言語は人間にわかりやすい形式になっているが、そのままでは機械は理解できない。そこで、プログラムを機械語に「翻訳する」必要がでてくる。この翻訳作業をするのがコンパイラである。

一口に「翻訳」と言っても、コンパイラがやるべき仕事は多い。まず「3 + 4」というひと続きの文字列が与えられたときに、「3」「+」「4」という文字に分割しなければならない。これを**字句解析**と呼ぶ。さらに、「3と4は整数であり、+という演算子の引数である」と認識する必要がある。これが**構文解析**と**意味解析**である。この構文解析を行うのがパーサ(parser, 構文解析器)である。パーサは、プログラムを**抽象構文木 (Abstract Syntax Tree, AST)**と呼ばれるデータ構造に変換する。

![コンパイラの仕事](fig/compile.png)

パーサによって抽象構文木が与えられたら、そこからアセンブリコードを生成する。通常は途中で中間コードを生成し、その後にアセンブリ言語に変換する。アセンブリを実行ファイルにするためには、さらに「リンク」という作業工程がある。リンクを行うのがリンカ(Linker)というプログラムで、これもかなり複雑なことをしているのだが、本講義では扱わない。

最初に、プログラム言語には大きく分けてコンパイル言語とインタプリタの二種類があることに触れた。プログラムをコンパイラが機械語に翻訳し、そのまま実行するのがコンパイル言語であり、C++などはコンパイル言語の代表格的な言語である。

一方、プログラム言語を逐次的に解釈して実行するのがスクリプト言語であり、Pythonもインタプリタ言語に属す。しかし、プログラムをそのまま解釈しながら実行すると遅いため、多くのスクリプト言語は「バイトコード」と呼ばれる中間コードを生成し、それを実行することで高速化を図る。

![インタプリタの仕事](fig/interpret.png)

Pythonは、まずプログラムを抽象構文木に変換する。その後、その構文木からバイトコードを生成する。バイトコードは仮想的な機械語である。機械語は、現実に存在する機械で動作するが、バイトコードは仮想的な機械向けの機械語である。このバイトコードを実行するプログラムを**仮想マシン(Virtual Machine, VM)**と呼ぶ。「エミュレータ」という言葉を聞いたことがあるかもしれない。昔のゲームハード用のゲームを、現在のゲームで実行するのに使われたりする。仮想マシンは、実際には存在しないハードウェアであるが、それを現実の計算機でエミュレートすることでプログラムを実行する。

本講ではPythonが動く仕組みを理解するため、実際に抽象構文木とバイトコードを見てみることにしよう。

## バイトコードとスタックマシン

Pythonは、与えられたプログラムを、仮想的なアセンブリであるバイトコードに変換し、それを仮想マシン上で実行する。Pythonの仮想マシンは、メモリとしてスタックを用いる。

![スタック](fig/stack.png)

スタック(Stack)とは、データ構造の一つである。重い荷物を積み上げたような状態を想像せよ。荷物は重いので、一度に一つしか持ち上げることができない。従って、「手持ちの荷物を一番上に積む」か「一番上の荷物を取り出す」ことしかできず、積み上がった荷物の途中に別の荷物を入れたり、一番上ではない荷物を取り出すこともできない。新しい荷物を一番上に載せることをプッシュ(push)、積み上がった荷物の一番上にあるものを取り出すことをポップ(pop)と呼ぶ。

スタックでは「入った順番」と「出る順番」が逆になっている。これを「後入れ先出し」の意味で**Last In First Out, LIFO**と呼ぶ。逆に、「最初に入った人が最初に出てくる」ようなデータ構造は「先入れ先出し」の意味で**First In First Out, FIFO**と呼び、このような振る舞いをするデータ構造を**キュー(Queue)**と呼ぶ。

Pythonはの仮想マシンは、スタックにデータをプッシュしたりポップしたりすることでプログラムを実行する。たとえば`3 + 4`というプログラムは、

```txt
LOAD_CONST 3
LOAD_CONST 4
BINARY_ADD
```

というバイトコード列に変換される。

`LOAD_CONST 3`は、スタックに「3」をプッシュせよ、という意味である。また、演算は、必要な数だけスタックからデータをポップして行う。例えば`BINARY_ADD`は、「スタックから二つデータをポップし、それを足した結果をまたスタックにプッシュせよ」という命令だ。以上の結果、スタックの一番上には演算結果である`7`がプッシュされる。

![スタックマシン上での加算](fig/binary_add.png)

このように、メモリとしてスタックを用いるような計算機を**スタックマシン**と呼ぶ。Pythonの仮想マシンはスタックマシンである。

既にみたように、スタックのデータのやりとりは「一番上」のみ、取り出せるデータも「最後に入れたもの」だけに限られ、途中にデータを挿入することも、任意の場所のデータを取り出すこともできない、いわば「不自由」なデータ構造である。なぜこのような「不自由」なデータ構造をメモリに採用しているかというと、命令セットが簡単になるというメリットがあるからである。

我々が通常使っている計算機は「レジスタマシン」と呼ばれる方式を採用している。レジスタマシンは、レジスタという計算を行うための小さく高速な作業領域を複数持ち、メモリも任意の場所に読み書きできる。すると、当然のことながら「メモリのどこから、どのレジスタに値をロードし、計算結果をどこに書き込むか」を指定しなければならない。それに対して、スタックマシンはメモリの「入り口」と「出口」が決まっているため、例えば足し算をする命令`BINARY_ADD`は引数を必要としない。このように、スタックマシンは命令セットが単純になるというメリットがあり、仮想マシンのモデルとして広く採用されている。

## 逆ポーランド記法

さて、先程見たように、`3 + 4`というプログラムは、

```txt
LOAD_CONST 3
LOAD_CONST 4
BINARY_ADD
```

という命令列に変換された。ここで、`LOAD_CONST`は省略し、かつ`BINARY_ADD`を`+`で表記すると、この命令列は`3 4 +`と表現できる。このように、演算子が、被演算子の後ろに置かれる記法を後置記法、もしくは**逆ポーランド記法(Reverse Polish Notation, RPN)**と呼ぶ。我々が普段目にする`3 + 4`という記法は、演算子が被演算子の中に置かれるため、中置記法と呼ばれる。

逆ポーランド記法は、スタックマシンと相性が良い。`3 4 +`という命令列が来た時、それを一つ一つの区切り(トークンと呼ぶ)に分解して、

* もしトークンが数字ならスタックにプッシュ
* もしトークンが演算子なら、スタックから二つデータを取り出して演算、結果をスタックにプッシュ

とするだけで計算が実行できる。

例えば、`a * b + c`という計算は、逆ポーランド記法なら`a b * c +`と表記できる。また、`a + b * c`の場合、先に`b * c`を実行する必要があるが、逆ポーランド記法なら`a b c * +`と表記され、演算子の優先順位を気にすることなく順番に処理すれば良い(より正確には、演算子の優先順位を考慮して逆ポーランド記法を構成する)。

実際にPythonのバイトコードが逆ポーランド記法になっているのを見てみよう。バイトコードを表示するには`dis`をインポートする。

```py
import dis
```

この状態で、

```py
dis.dis("a * b + c")
```

を実行すると、

```txt
  1           0 LOAD_NAME                0 (a)
              2 LOAD_NAME                1 (b)
              4 BINARY_MULTIPLY
              6 LOAD_NAME                2 (c)
              8 BINARY_ADD
             10 RETURN_VALUE
```

となり、これが`a b * c +`に対応しているのがわかるであろう。

![`a * b + c`の計算](fig/calc1.png)

また、

```py
dis.dis("a + b * c")
```

を実行すると

```txt
  1           0 LOAD_NAME                0 (a)
              2 LOAD_NAME                1 (b)
              4 LOAD_NAME                2 (c)
              6 BINARY_MULTIPLY
              8 BINARY_ADD
             10 RETURN_VALUE
```

となる。これが`a b c * +`になっていることは見てわかるであろう。

![`a + b * c`の計算](fig/calc2.png)

# Pythonはどうやって動くのか：課題

## 課題1：抽象構文木とバイトコード

### 課題1-1：抽象構文木の可視化

Pythonのプログラムが抽象構文木に変換される様子を観察してみよう。新しいノートブックを開き、`ast.ipynb`として保存せよ。

#### 1. ライブラリのインポート

最初のセルで必要なライブラリをインポートする。

```py
import ast
import dis
from IPython.display import Image, display_png
from graphviz import Digraph
```

#### 2. 抽象構文木をグラフに変換する関数

抽象構文木を解析してグラフに変換する関数`visit`を書く。

```py
def visit(node, nodes, pindex, g):
    name = str(type(node).__name__)
    index = len(nodes)
    nodes.append(index)
    g.node(str(index), name)
    if index != pindex:
        g.edge(str(pindex), str(index))
    for n in ast.iter_child_nodes(node):
        visit(n, nodes, index, g)
```

`__name__`は前後にアンダースコアが二つずつであることに注意。

#### 3. グラフを可視化する関数

抽象構文木をグラフとして可視化する関数`show_ast`を書く。

```py
def show_ast(src):
    graph = Digraph(format="png")
    tree = ast.parse(src)
    visit(tree, [], 0, graph)
    graph.render("test")
    display_png(Image("test.png"))
```

`ast.parse`は、引数として与えられた文字列をPythonのプログラムとして解釈し、抽象構文木に変換する。返り値は、構文木の根(root)である。それを`ast.iter_child_nodes`に渡すと、そこにぶら下がるノードが返ってくるので、それらすべてに対してfor文をまわして、子ノードに対して再帰的に`visit`を呼び出し、子孫ノードを取得していく、というのがこのコードの仕組みである。

#### 4. 抽象構文木の表示

ここまで作成した関数を使って、プログラムの抽象構文木を表示させて見よう。解析したいソースコードを`src`という文字列に代入し、`show_ast(src)`を呼ぶことで抽象構文木を表示することができる。

```py
src="""
3+4
"""
show_ast(src)
```

ここまで正しく入力されていれば、抽象構文木のグラフが表示されるはずである。うまくできたら、パースするプログラム文字列を変え、別のプログラムをパースしてみよ。まずは`3+4`の`+`を`-`や`/`、`//`に変えてみよ。次に、以下のプログラムをパースせよ。

```py
a, b = (1,2)
```

```py
def func(a,b):
    return a+b
```

```py
for i in [1,2,3]:
    print(i)
```

上記のプログラムを入力するには、`"""`で囲まれた領域に入力すること。例えば最初の例なら、

```py
src = """
a, b = (1,2)
"""
```

と入力する。抽象構文木とプログラムの対応がわかるだろうか？

### 課題1-2：バイトコード

#### 5. バイトコードの表示

以下のプログラムを実行し、バイトコードが得られることを確認せよ。

```py
dis.dis("a + b")
```

バイトコードが得られたら、以下のプログラムに対応するバイトコードを出力し、逆ポーランド記法となっていることを確認せよ。

* `a + b`
* `a - b`
* `a * b + c`
* `a + b * c`

## 課題3：スタックマシンの実装

最も簡単なスタックマシンの例として、逆ポーランド記法による計算機を実装してみよう。新しいPython3ノートブックを開き、`calc.ipynb`として保存せよ。

### 課題3-1: 逆ポーランド記法電卓

逆ポーランド記法で記述された計算式を評価する計算機を作りたい。逆ポーランド記法とは、「3 + 4」を「3 4 +」と表記する方式だ。人間には読みづらいが、電卓を実装しやすい、という特徴がある。

具体的には、以下のような「プログラム」を組む。

* プログラムは、整数、'+'、`-'の三種類の**トークン**で構成される
* プログラムを一つ読み込み、以下の動作をする
  * プログラムが演算子なら、スタックから二つデータをポップして、計算し、結果をプッシュする
  * 整数なら、そのままスタックにプッシュする
* プログラム終了時、スタックの一番上にある数字を表示して終了する

#### 1. ライブラリのインポート

まずは必要なライブラリをインポートしておこう。

```py
import dis
```

#### 2. 計算機の実装

では計算機のプログラムを記述しよう。まずは加減算のみに対応させる。最初のセルに以下を入力せよ。

```py
def calc(code):
    data = code.split()
    stack = []
    for x in data:
        print(stack, x, end=" => ")
        if x == '+':
            b = stack.pop()
            a = stack.pop()
            stack.append(a+b)
        elif x == '-':
            b = stack.pop()
            a = stack.pop()
            stack.append(a-b)
        else:
            stack.append(int(x))
        print(stack)
    print(stack.pop())
```

#### 2. 計算のテスト

実際に計算してみよう。2つ目のセルで以下を実行せよ。

```py
calc("1 2 +")
```

以下のような実行結果が得られたはずである。

```txt
[] 1 => [1]
[1] 2 => [1, 2]
[1, 2] + => [3]
3
```

これは、

* 最初はスタックが空`[]`で、そこに`1`が来たのでプッシュされて`[1]`になった
* 次に`2`が来たので、それもプッシュしてスタックの状態が`[1,2]`になった
* 次に`+`が来たので、スタックから値を二つ取り出し、その和をプッシュして`[3]`になった
* 実行すべきプログラムがなくなったので、スタックの一番上にある数字`3`を表示して終了

という順番で実行されている。

### 課題3-2: 乗算、除算の実装

作成した電卓に、乗算と除算を実装せよ。ただし、除算に関しては、入力プログラムとしては`\`を入力するが、実際の処理では`\\`を実行することで、実行結果を整数にすること。

以下の「プログラム」に対して、以下のような実行結果が得られれば正しく実装できている。

```py
calc("1 2 + 3 * 4 /")
```

```txt
[] 1 => [1]
[1] 2 => [1, 2]
[1, 2] + => [3]
[3] 3 => [3, 3]
[3, 3] * => [9]
[9] 4 => [9, 4]
[9, 4] / => [2]
2
```

### 課題3-3: 複雑な計算

以下の中置記法の計算式を、逆ポーランド記法に「頭で」変換し、先程の計算で実行せよ。演算子の優先順位も考慮すること。

* `3 + 4 + 5`
* `3 + 4 * 5`
* `3 + 4 * 5 - 12`
* `(1 + 4 * 5) / 7`

ヒント：`dis`を用いることで、演算順序がわかる。例えば

```py
dis.dis("a + b * c")
```

を実行すると、スタックに積む順番と演算を実行する順番がわかる。ここで、`dis`には数字を入力するのではなく、アルファベットを入力すること(数字を入力すると最適化で計算されてしまうため)。

### 発展課題

注：この課題はかなり難しいので、無理に取り組まなくても良い。

中置記法の計算式を、逆ポーランド記法に変換するコードを作成せよ。括弧は実装しなくてよいが、乗算や除算は加減算より優先されなくてはならない。例えば、

* `1 + 2 * 3`

という入力が与えられたら、

* `1 2 3 * +`

という文字列を出力しなければならない。

実装のヒント：

バッファとスタックを用意する。

* プログラムから一つトークンを取り出す
* もしトークンが数字ならバッファにプッシュする
* もしトークンが`*`か`/`ならスタックにプッシュする
* もしトークンが`+`か`-`なら、スタックが空になるか、スタックの最上位が`+`もしくは`-`になるまで、「スタックからポップしてバッファにプッシュする」を繰り返す
* プログラムからすべてトークンを取りだしたら、スタックが空になるまで「スタックからポップしてバッファにプッシュする」を繰り返す

以上を実装すると、バッファに逆ポーランド記法の順序でトークンが並ぶので、`" ".join(buffer)`を実行すれば所望の文字列を得る。

## AIに悪意はあるか

AIに意識があるか、という問題は難しい。個人的には「チューリングテストをパスしたAIには意識があるとみなす」という立場であり、究極的には人間の意識とAIの持つ「意識」は区別不可能となる未来が来るだろうと思っているが、現時点ではAIは発展途上であり、「あぁ、まだソフトウェアなんだな」と思う時と「人間と同じ問題を抱えているのでは」と思う時の両方がある。

「あ、AIはただのソフトウェアなんだな」と思う例の一つは画像認識である。「犬」「猫」「羊」などのラベルがついた画像を事前に学習させておくことで、写真に何が写っているかを認識するAIを作るものだ。一見するとこのAIは写真に写るものを正しく認識しているように見えるが、何もいない草原に「羊がいる」と判断してしまう。「羊」のラベルがついた画像のほとんどが草原であったため、「草原＝羊」と認識してしまったのだ。逆に、子供が牧場で羊を抱きかかえる写真を見て「犬」と判断してしまうこともあった。草原以外にいる羊のデータがなかったためだと思われる。同様な例に「ハスキーと狼問題」がある。シベリアン・ハスキーは狼に似た犬種であるが、そのハスキーと狼を見分けるAIを作ったところ、実は犬ではなく「背景に雪があるかどうか」で判断していることがあった。

多くの場合、こうした画像認識の失敗は笑い話で済むが、差別問題がからむとやっかいなことになる。2015年、Googleは、写真管理アプリGoogle Photosをリリースしたが、そのアプリには写真に写っているものを認識し、ラベル付けする機能があった。しかし、黒人女性が写る写真に「ゴリラ」とタグ付けしてしまい、GoogleのChief Social Architectが謝罪する事態となった。これについては「差別的な人間が黒人に『ゴリラ』という差別的なタグをつけていたものを学習したせいだ」という噂も流れたが、どうやら純粋に「白人以外」のデータが足りずに、素で間違ったようだ。他にも、やはり黒人女性を「猿(Apes)」と認識してしまうことがわかった。結局Googleは根本解決ができず、「ゴリラ、猿、チンパンジー」といったラベルを禁止ワードにすることで対処することになった。

Google翻訳がジェンダーバイアスを持つことも知られている。例えば現時点(2019年12月4日現在)では、「**医者** は旅行先でカバンを忘れてきた。」は「The doctor has forgotten **his** bag at the travel destination.」と訳すが、「**看護師** は旅行先で……」とすると「The nurse has forgotten **her** bag when traveling.」と訳す。Google翻訳は多くの翻訳例を通じて学習したモデルを用いているが、そのデータ上で「Docter」が「his」と、「Nurse」が「her」と一緒に用いらていれることが多かったのだと思われる。

Google Photosの問題は「学習データに白人が多く黒人が少なかったため」に起きたことであり、Google翻訳の問題は学習用データを通じて「医者は男性が多く、看護師は女性が多い」という「偏見」も一緒に学習してしまったために起きたことだ。現時点では「AI」に罪はなく、「AIの学習過程で人間持つの差別や偏見が注入された」と認識されているが、そもそも学習で偏った情報に触れて偏見を身につけてしまうという過程は人間と全く同じである。既に自らの過ちをAIのせいにしている人も出現しており、そのうちAIが高度に発展した場合、我々はAIそのものに悪意や偏見を感じるようになるのかもしれない。

* Notes on AI Bias[https://www.ben-evans.com/benedictevans/2019/4/15/notes-on-ai-bias](https://www.ben-evans.com/benedictevans/2019/4/15/notes-on-ai-bias)
