# Pythonはどうやって動くのか

* コンピュータはなぜ動くのか？
* プログラム言語とは
* Pythonが動く仕組み1: 抽象構文木
* Pythonが動く仕組み2: バイトコードと仮想マシン
* 仮想マシンハック(やるんですか？)抽象構文木をいじる程度にするかな。

## コンピュータはなぜ動くのか？

車を運転していない人でも、車はガソリンという可燃性の液体を燃料とし、それを噴射して点火、爆発させてピストンを動かし、そのピストンの運動を回転運動に変換してタイヤに伝えて動いている、ということはぼんやりと知っていることだろう。この知識は、車を運転するときにはあまり必要ない。実際、車の運転をする際にエンジンやトランスミッションの仕組みを意識することは(よほど車好きでない限り)稀であろう。しかしそれでも、車の仕組みは簡単に知っておくべきだと思う。冷蔵庫や電子レンジ、これらの家電は、その動作原理を知らずとも使うことは可能だし、おぼろげに原理を知っているからといってあまり役に立つ気はしないが、やはりざっくりとは知っておくべきだと思う。それが教養というものだ。コンピュータの動作についても同様である。

これまで、ブラウザ上でプログラムを入力し、実行させ、その結果を表示させてきた。Pythonのプログラムはクラウド上で実行されたが、そのブラウザを実行しているのは皆さんの目の前にあるのはコンピュータである。コンピュータとはcomputeするもの、つまり計算機であり、何かしら計算してその結果を表示することを繰り返す機械である。では、そもそもプログラムとはどうやって動いているのだろうか？せっかくプログラミングを覚えるのだから、計算機がどういう仕組みで動いているのか知っておいた方が良いだろう。なお、私は古い人間なので、コンピュータのことをどうしても「計算機」と呼んでしまう。以後、パソコンやCPUなどを指して「計算機」と呼ぶのでそのつもりでいて欲しい。

いま、目の前にある計算機は、ディスプレイ(表示装置)、キーボードやマウス(入力装置)、CPU(中央演算処理装置)、メモリ(記憶装置)などから構成されている。ディスクなどのストレージやネットワークなどの通信装置については今は忘れよう。このうちCPUがもっとも重要な装置であるが、やっていることは非常に単純で、

* メモリから命令とデータを取ってくる
* 命令を解釈し、データを演算器に投げる
* 演算器から返ってきた結果をメモリに書き戻す

ということをひたすら繰り返しているに過ぎない。「命令」も一種のデータであり、メモリに置いてあることに注意しよう。演算器というのは、文字通り演算する機械である。例えば足し算をしたければ加算器を、掛け算をしたければ乗算器が必要になる。また、整数演算と浮動小数点演算は全く異なる演算器を用いる。

さて、計算機が解釈できるのは数字だけである。したがって、人間が計算機に命令するためには、機械語(マシン語)と呼ばれる数字の羅列を使う必要がある。コンピュータとは計算機であり、計算とはデータに四則演算などの演算をすることである。したがって、計算機に何か計算させたければ「何を(データ)」「どうするか(命令)」がセットである必要があることがわかるだろう。機械語というと難しそうだが、結局のところ「何を」「どうするか」を羅列しているに過ぎない。

![opcode.png](opcode.png)

例えば一桁の整数を二つ受け取って四則演算をする計算機があったとしよう。四則演算をするので、演算は加算、減算、乗算、除算の四種類である。なのでそれぞれに0,1,2,3の数字を割り当てよう。四則演算をするには、整数が二つ必要だ。その数字も並べよう。例えば「034」という数字列は「3+4」を、「185」は「8-5」を表す。計算機は、メモリから三つの数字をとってきて、最初の数字を見て「どの演算器に投げるか」を決める(命令を最初に置いたのはそのためだ)。そして続く二つのデータを演算器に投げる。かなり単純化されているが、これが機械語である。

## プログラム言語とは

さて、計算機が解釈できるのは機械語だけである。機械語は難しくはないが、「足し算は0で・・・」と覚えるのは面倒だ。そこで「034」という数字の羅列の代わりに「ADD 3,4」という書き方をしよう。これを「034」に変換するのは簡単だし、人間が見て「3と4を足すんだな」とわかりやすい。このように機械語と一対一対応する言語を「アセンブリ言語(Assembly Language)」と呼ぶ。しかし、アセンブリ言語でもまだ面倒だ。もっと、人間にわかりやすい形式、先ほどの例なら「3+4」と書いて、それを計算機が理解できる形式に変換したい、と思うのは自然であろう。その「人間が理解できる形式」がプログラム言語と呼ばれるものである。

プログラム言語は人間にわかりやすい形式になっているが、その分、計算機に分かりやすい形に直すのにいくつか手続きが必要になる。まず「3+4」という文字列が与えられたときに、これが「3と4は整数、+は演算子であり、先の3と4を引数に取っている」と認識しなければならない。この作業を行うのが「パーサ」と呼ばれるプログラムである。パーサは、プログラムを「抽象構文木 (Abstract Syntax Tree)」と呼ばれるデータ構造に変換する。

![ast.png](ast.png)

プログラム言語には、大きく分けてコンパイル言語とインタプリタの二種類がある。C++などはコンパイル言語の代表格的な言語である。コンパイラと呼ばれるプログラムが、人間の書いたプログラムをあらかじめ全て機械語に翻訳してから実行する。インタプリタとは、人間の書いたコードを逐次的に解釈しながら実行する方式であり、Pythonもインタプリタに属す。しかし、プログラムをそのまま解釈、実行すると遅いため、Pythonは「バイトコード」と呼ばれる中間形式を出力し、それを実行することで高速化を図る。バイトコードを実行するプログラムを仮想マシン(Virtual Machine, VM)と呼ぶ。Javaは事前にプログラムをコンパイルするが、出力するのは現実の機械の機械語ではなく、仮想機械の機械語であり、それを仮想機械上で実行する。また、clangは、LLVMという仕組みを使い、まず仮想機械の機械語を出力してから現実の機械語に変換する。

TODO: このあたりの言語の実行の仕組みの図解
TODO: VMの説明。Javaとの比較など
TODO: レジスタマシン、スタックマシンの説明もする？高度すぎか？

## Pythonが動く仕組み1: 抽象構文木

ではまず、Pythonのプログラムが抽象構文木に変換される様子を観察してみよう。新しいノートブックを開き、以下のプログラムを4つのセルに分けて入力せよ。

```py
import ast
import sys
import IPython
from graphviz import Digraph
```

```py
def visit(node, nodes, pindex, g):
    name = str(type(node).__name__)
    index = len(nodes)
    nodes.append(index)
    g.node(str(index), name)
    if index != pindex:
        g.edge(str(index), str(pindex))
    for n in ast.iter_child_nodes(node):
        visit(n, nodes, index, g)
```

```py
src = """
3+4
"""
```

```py
graph = Digraph(format="png")
tree = ast.parse(src)
visit(tree, [], 0, graph)
graph.render("test")
IPython.display.Image("test.png")
```

正しく入力されていれば、4つ目のセルを入力、実行したところで、抽象構文木のグラフが表示されるはずである。
これは、三つ目のセルで入力した以下のプログラムをパースしたものだ。

```py
3+4
```

`ast.parse`は、引数として与えられた文字列をPythonのプログラムとして解釈し、抽象構文木に変換する。返り値は、構文木の根(root)である。
それを`ast.iter_child_nodes`に渡すと、そこにぶら下がるノードが返ってくるので、それらすべてに対してfor文をまわして、子ノードに対して再帰的にまたその子ノードを取得するプログラムである。

### 課題1

先ほどの三番目のセル(入力するプログラムを与えるセル)の文字列を変え、別のプログラムをパースしてみよ。まずは`+`を`-`や`/`、`//`に変えてみよ。次に、以下のプログラムをパースせよ。

```py
a, b = (1,2)
```

```py
def func(a,b):
    return a+b
```

```py
for i in [1,2,3]:
    print(i)
```

上記のプログラムを入力するには、`"""`で囲まれた領域に入力すること。例えば最初の例なら、

```py
src = """
a, b = (1,2)
"""
```

と入力する。何が作られて、何にアサインされているだろうか？

## Pythonが動く仕組み2: バイトコードと仮想マシン

TODO: dis.disによるバイトコードの確認

## 余談：機械がやるべきこと、やるべきでないこと

今でこそ「面倒な単純作業は人間ではなく機械にやらせるべき」という考えが(たぶん)浸透しているが、昔は計算機は非常に高価であり、その計算時間は貴重な資源であった。アセンブリを機械語、つまり数字の羅列に変換するのを「アセンブル」と呼ぶが、それを人間が手で行うことを「ハンドアセンブル」と言う。計算機が使われ始めた当初は、もちろんアセンブラなどなかったから、みんなハンドアセンブルをしていた。さて、世界で初めてアセンブラを作ったと思われているのはドナルド・ギリース(Donald B. Gillies)である。1950年代、ギリースは、フォン・ノイマンの学生だった時、アセンブリを機械語に自動で翻訳するプログラムを書いていた。ギリースがアセンブラを書いているのをフォン・ノイマンが見つけたときのことを、ダグラス・ジョーンズという人が以下のように[紹介](https://groups.google.com/forum/#!msg/alt.folklore.computers/2fdmW2PU8dU/OJ_-6BjoP0YJ)している。

> John Von Neumann's reaction was extremely negative.  Gillies quotes his boss as having said "We do not use a valuable scientific computing instrument to do clerical work!" (I wish I could reproduce Gillies' imitation of Von Neumann's Hungarian accent, he was very good at it!)

(適当な訳)

>ノイマンの反応は極めてネガティブだった。ギリースはボス(ノイマンのこと)の口真似をしながらこう言った「我々は貴重な科学計算機をそのようなつまらない仕事に使うべきでない！」 (ギリースの口真似を再現できたらと思う。彼はフォン・ノイマンのハンガリー訛りの英語の真似がすごく上手いんだ)

現在、「AIが人間を超える(シンギュラリティ)」とか「AIにより人間の仕事が奪われる」とかいった、一種の終末思想が盛んに喧伝されている。私はAIの専門家ではないので、将来どうなるかはわからない。しかし、AIは人間が作るものである。自動車ができたら、運転手という職業ができたように、「AIが人間の可能性を奪う」という「引き算の考え」よりは、「AIと人間の組み合わせで新たな可能性が生まれる」と「足し算の考え」でポジティブに考えたい。おそらくそのほうが生産的であろう。

## より詳しく学ぶために

もしアセンブリや機械語に興味がある人がいたら、tanakmuraさんの[実践的低レベルプログラミング](https://tanakamura.github.io/pllp/docs/index.html)の[x86_64 機械語入門](https://tanakamura.github.io/pllp/docs/x8664_language.html)を参照せよ。
