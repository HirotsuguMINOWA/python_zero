
# [NumPyとSciPyの使い方](https://kaityo256.github.io/python_zero/numpy/)

## 本講で学ぶこと

* NumPyの使い方
* SciPyの使い方
* シュレーディンガー方程式と固有値問題
* 特異値分解と画像近似

## NumPyとSciPy

Pythonには強力なライブラリが多数存在し、それらを使いこなすことで、少ない記述で豊富な機能を素早く実装することができる。今回は、数多くのライブラリの中でも、数値計算、特に行列演算を効率的に行うことができるNumPyと、それを用いて様々な科学的な計算を行うことができるライブラリ、SciPyを使ってみる。

なお、今回の講義でNumPyやSciPyの使い方を覚える必要はない。ただ、PythonにはNumPyやSciPyというライブラリがあり、数行書くだけで行列の固有値問題を解くことができる、ということをぼんやり覚えておいて、将来、必要になった時にそれを思い出して、詳細については本を読むなりウェブで検索するなりすればよい。

## Numpyの使い方

### NumPyとは

数値計算では、行列を扱うことが非常に多い。行列がからむ演算の中で特に重要なのが、行列同士の積の計算だ。行列と行列の積を(そのまんまだが)行列行列積と呼ぶ。スーパーコンピュータにはTop500という性能ランキングがあり、年に二回ランキングが更新されるが、そこで行われているベンチマークは巨大な連立一次方程式をどれだけ効率的に解くことができるか、という問題である。そして、その計算の中心は行列行列積である。従って、Top500における「スパコンの性能」は、「いかに行列同士の積を早く計算できるか」に依存している。

行列の積の定義そのものは簡単だ。普通にかけば三重ループで計算できる。しかし、現代の計算機では行列の乗算の効率的な実装は非常に面倒であり、「普通」に書くとまったく性能がでない。なにしろ行列行列積は数値計算の根幹をなす演算であり、そこが遅いと非常に広範囲の計算が影響を受けてしまう。そこで、Pythonにおいて行列を効率的に扱うためのライブラリが作られた。それがNumPyである。

NumPyを使うには、まず`numpy`をインポートする。`np`という別名をつけるのが慣習である。

```py
import numpy as np
```

### NumPy配列の作り方

NumPy用の配列(NumPy配列)を作成するにはいくつか方法があるが、てっとりばやいのは`np.array`にリストを与えることだ。例えば以下は二行二列の行列を作る例である。

```py
a = np.array([[1,2],[3,4]])
print(a)
```

```txt
[[1 2]
 [3 4]]
```

要素が全てゼロの配列を作るには、`zeros`を使えばよい。

```py
z = np.zeros((2,2))
print(z)
```

```txt
[[0. 0.]
 [0. 0.]]
```

NumPy配列のデータには「型」がある。Pythonのリストは複数の型の混在が許されたが、NumPy配列は全て同じ型でなければならない。NumPy配列のデータの型は`dtype`で調べることができる。

```py
print(a.dtype) #=> int64
print(z.dtype) #=> float64
```

`np.array`で作った場合は、与えたリストから推定された型が使われるが、`np.zeros`の場合はデフォルトで`float64`の型になる。明示的に型を指定すれば、その型のゼロ要素行列を得ることができる。

```py
z2 = np.zeros((2,2),dtype=np.int64)
print(z2.dtype) #=> int64
```

### NumPy配列同士の演算

NumPy配列は、「形」を保持しており、`shape`でその形を知ることができる。`shape`は、タプルの形で返ってくる。

```py
a.shape #=> (2,2)
```

形が同じ行列同士は四則演算ができる。ここで`*`を計算すると、行列積ではなく、「要素ごとの積」を計算することに注意。

```py
b = np.array([[5,6],[7,8]])
print(a*b)
```

```txt
[[ 5 12]
 [21 32]]
```

行列行列積を計算したい時には`dot`を用いる。

```py
c = a.dot(b)
print(c)
```

```txt
[[19 22]
 [43 50]]
```

### NumPy配列の中身

NumPy配列は、どのような「形」でも作ることができる。通常の行列は「行」と「列」のある二次元のデータだが、三次元でも四次元でも作ることができる。しかし、NumPy配列は、実はどのような形であろうとも一次元配列として保存されている。NumPy配列は、一次元のデータ`shape`プロパティによってどのような形として解釈するかを決めている。`reshape`を使うことで、データを変更せずに「形」を変えることができる。

連番の要素を持つ一次元のNumPy配列を作るには、`arange`を使う。

```py
a = np.arange(8)
print(a)
```

```txt
array([0, 1, 2, 3, 4, 5, 6, 7])
```

このデータを「4行2列の行列」として解釈したNumPy配列を得るには、以下のようにすれば良い。

```py
b = a.reshape((4,2))
print(b)
```

```txt
[[0 1]
 [2 3]
 [4 5]
 [6 7]]
```

`reshape`にはタプルを渡す。総データ数さえ等しければどのような形にもできる。例えば`(2,2,2)`という形にもできる。

```py
c = a.reshape((2,2,2))
print(c)
```

```txt
[[[0 1]
  [2 3]]

 [[4 5]
  [6 7]]]
```

`reshape`は、データ数が合わないとエラーとなる。

```py
a.reshape((4,4)) #=> ValueError: cannot reshape array of size 8 into shape (4,4)
```

## SciPyについて

SciPyは、NumPyを基礎にした科学計算ライブラリだ。非常に多くのことができるが、それゆえにその全てを説明することはできない。ここでは、行列の固有値と固有ベクトルだけ求めてみよう。

固有値や固有ベクトルを求めるには`scipy.linalg`をインポートすればよい。多くの場合、一緒に`numpy`もインポートするであろう。

```py
from scipy import linalg
import numpy as np
```

固有値、固有ベクトルは、`linalg.eig`で求めることができる。

```py
a = np.array([[1,2],[2,1]])
w, v = linalg.eig(a)
```

これで、`w`に固有値が、`v`に固有ベクトルがそれぞれリストの形で返ってくる。

例えば固有値は

```py
print(w) #=> [ 3.+0.j -1.+0.j]
```

つまり「3」と「-1」である。一般に固有値は複素数となるが、今回のように入力が実対称行列(もしくはエルミート行列)であることがわかっていれば、エルミート行列向けの`eigh`が使える。

```py
w, v = linalg.eigh(a)
print(w) #=> [-1.  3.]
```

エルミート行列の固有値は常に実数であるから、返り値も実数となる。

## シュレーディンガー方程式

TODO: トンネル効果の説明

TODO: 離散化の説明

## 特異値分解による画像圧縮

TODO: 長方形の積でより大きな行列を作ることの図解
TODO: 特異値分解の説明

# NumPyとSciPyの使い方：課題

## 課題1：シュレーディンガー方程式

### 1. ライブラリのインポート

```py
import matplotlib.pyplot as plt
from scipy import linalg
import numpy as np
```

### 2. 行列の作成

```py
N = 32
V = np.array([-5.0 if i in range(N//4, 3*N//4) else 0 for i in range(N)])
A = np.zeros((N, N))
for i in range(N):
    i1 = (i + 1) % N
    i2 = (i - 1 + N) % N
    A[i][i] = 2.0 + V[i]
    A[i][i1] = -1
    A[i][i2] = -1
```

### 3. 固有値と最低固有エネルギー

得られた行列の固有値、固有ベクトルを求め、さらに固有値の中でもっとも値が小さいもののインデックスを求めよう。

```py
w, v = linalg.eigh(A)
i0 = np.argmin(w)
print(w[i0])
```

最小値を求めるだけなら`np.min(w)`で良いが、後で対応する固有ベクトルを使うのにインデックスが必要なので、`np.argmin(w)`を利用している。

実行してみると、-5よりも若干大きな値が表示されたはずである。これが「閉じ込めエネルギー」と呼ばれるものだ。

#### 4. 波動関数の可視化

井戸型ポテンシャルに閉じ込められた波動関数の可視化をしてみよう。波動関数は、その二乗が電子の「存在確率」を表す。先ほど得た「最低固有エネルギー」に対応する固有ベクトルを二乗したものを、ポテンシャルと一緒にプロットしてみよう。

```py
v = v.transpose()[i0]
v = v * v
plt.plot(v*20+w[i0])
plt.plot(V)
```

少し確率が井戸の外にしみだしていることがわかるはずである。これが「トンネル効果」と呼ばれるものだ。

## 課題2：行列の近似による画像処理

## 余談：ライブラリについて

スクリプト言語は同時通訳で、コンパイラ言語は事前翻訳である。なんとなく同時通訳で情報を処理するより、事前に全て翻訳しておいた方が実行が早そうな気がするであろう。スクリプト言語よりもコンパイラ言語の方が「同時通訳」というオーバーヘッドがなく、さらにコードの最適化に時間をかけられることもあって、「一般論としては」同じことをするならコンパイラ言語の方が早い。しかし、現実はさほど単純ではない。

通常、スクリプト言語は豊富なライブラリを持つ。ライブラリとは、よく使う機能をパッケージ化したものだ。ライブラリは、その言語そのもので書かれたものもあるが、時間がかかる処理についてはCやFortranなどの言語で記述され、事前にコンパイルされている。特に数値計算ライブラリは高度に最適化されていることが多く、よほどのことがなければ自分でCやFortranで書くより、Pythonからライブラリを呼び出した方が高速に実行できる。また、速度が不要である場合でも、Pythonからライブラリを呼び出して書いた方が、Cなどのコンパイラ言語で書くより早く開発できることが多い。本講で扱ったNumpyはそのような強力なライブラリの一つだ。

よくプログラミング言語の優劣について聞かれるのだが、個人的な印象でいえば文法などはあまり重要でないと感じる。極論すれば、言語の優劣はライブラリの豊富さで決まる。Pythonには強力なライブラリが豊富にある。ある目的のために複数のライブラリを束ねたものをフレームワークと呼ぶ。Pythonには機械学習のフレームワークが多数存在し、機械学習を行うプログラミング言語のデファクトスタンダードとなっている。いずれにせよ、「とりあえずPythonを使って何かしたい」場合、Pythonの細かい文法を気にするより「当面はライブラリの使い方を学ぶ」と割り切った方が生産的だと思う。

TODO: BLASについて追記する
