# 第二講

## 本講で学ぶこと

* 組み込み型
* 関数の宣言と利用方法
* 繰り返し処理
* 条件分岐

## 組み込み型

Pythonに限らず、プログラム言語には「型 (type)」がある。「型」とは、そのデータが何を表現しているかを表すものである。
「型」は自分で作ることもできるが、言語にもともと備わっている型もあり、それを「組み込み型 (Built-in types)」と呼ぶ。

### 真偽値

「真(True)」であるか「偽(False)」であるかの二値だけを取る型です。比較や論理演算ができる。
条件分岐などで使われる。

```py
True #=> True
False #=> False
True and False #=> False
True or False #=> True
not True #=> False
not False #=> True
```

### 整数

「1」「2」「3」といった整数を表現する。四則演算や比較などができる。負の数も扱える。

```py
1 # => 1
1 + 2 # => 3
2 * 6 # => 12
2 - 5 # => -3
```

整数同士を比較すると真偽値になる。

```py
1 == 1 #=> True
1 == 2 #=> False
1 != 1 #=> False
1 != 2 #=> True
1 < 2  #=> True
1 > 2  #=> False
```

### 浮動少数点

「0.1」「123.45」といった、整数ではない値を表現する。整数と同様に四則演算や比較ができるし、負の数も扱える。

```py
0.5 + 0.5 #=> 1.0
0.5 * 0.5 #=> 0.25
0.5 < 1.0 #=> True
```

ただし、浮動小数点数は内部的には **その数値に最も近い近似値** を扱っているため、誤差が存在する。例えば0.1を3回足しても0.3にならない。

```py
0.1 + 0.1 + 0.1 #=> 0.30000000000000004
0.1 + 0.1 == 0.2 # => True
0.1 + 0.1 + 0.1 == 0.3 #=> False
```

したがって、** 浮動小数点数同士の等号比較は信頼できない **。浮動小数点数同士の等号比較は、意図通りに動作したりしなかったりする。
初心者がよく入れるバグなので注意すること。

整数と浮動小数点数の演算結果は、(たとえ結果が整数になろうとも)浮動小数点数になる。

```py
0.5*2 #=> 1.0
```

### 整数の除算と余り

整数同士の割り算は(たとえ演算結果が整数であろうとも)浮動小数点数になる。

```py
6/3 #=> 2.0
```

もし、整数の割り算で整数を得たい場合(商を求めて余りを無視したい場合)は`//`を用いる。

```py
6//3 # => 2
5//2 #=> 2
```

整数の割り算で余りが欲しい場合は`%`を用いる。

```py
6%3 #=> 0
5%2 #=> 1
```

### 複素数

Pythonは複素数も扱うことができる。虚数単位がjなので注意。実部、虚部は`real`、`imag`で取り出すことができる。
また、整数で記述しても浮動小数点数として扱われることに注意。

```py
1 + 2j # => (1+2j)
(1+2j) + (2+4j) #=> (3+6j)
(1+2j)*(1-2j) => (5+0j)
(1+2j).real #=> 1.0
(1+2j).imag #=> 2.0
```

## 変数

プログラム言語では、値にラベルをつけることができる。そのラベルは、値として振る舞う。このラベルを「変数 (variable)」と呼ぶ。

```py
a = 1
print(a) # => 1
a + 1 #=> 2
```

値は演算結果で上書きすることができる。

```py
a = 1
print(a) # => 1
a = a + 1
print(a) # => 2
```

## 関数

Pythonでは、よく使う処理を「関数」という形で定義し、何度も利用することができる。

```py
def sayhello():
  print("Hello!")
```

定義した関数は後で何度でも呼ぶこともできる。

```py
sayhello() #=> "Hello!"
```

関数にインプットを与えることもできる。このインプットを「引数(ひきすう)」と呼ぶ。

```py
def say(s):
  print(s)
```

```py
say("Bye!") #=> Bye!
```

関数を実行した結果、値を返すこともできる。返す値は`return`文で指定する。

```py
def add(a, b):
    return a + b
```

```py
add(3, 4) #=> 7
```

関数が返した値を変数に代入することもできる。

```py
a = add(1, 2)
print(a) #=> 3
```

## 繰り返し処理

### for文

TODO:後で書く

### while文

TODO:後で書く

## Collatz問題

まずはプログラムを作ってみよう。題材としてCollatz問題を取り上げる。
Collatz問題とは、以下のようなものである。

* 何か正の整数を考えよ
* それが偶数なら2で割れ
* それが奇数なら3倍して1を足せ
* 以上の処理を数字が1になるまでずっと繰り返せ

たとえば「5」を考えよう。これは奇数なので3倍して1を足すと「16」になる。
これは偶数だから2で割って「8」、さらに2で割って「4」「2」「１」となる。

Collatz問題とは「すべての整数について有限回の手続きで1になるか？」というものであり、現在も解決されていない。
もし有限の手続きで1にならないとしたら、どこかに無限に大きくなるか、ループする構造があるはずだが、今の所どちらも見つかっていない。

### 課題1

与えられた数字に対して、

* 偶数なら2でわる
* 奇数なら3倍して1を足す

という処理を、その数字が1になるまで繰り返しながら表示する関数`collatz`を作りたい。
以下の空欄を埋めよ。

```py
def collatz(i):
  print(i)
  while (条件1):
    if (条件2):
      i = i //2
    else:
      i = i * 3 + 1
    print(i)
```

インデントに注意。最初の`print`と二番目の`print`はインデントの位置が異なる。

完成したら、関数を入力したセルを実行してから、別のセルに以下のように関数呼び出しを入力、実行し、結果が一致することを確認せよ。

```py
collatz(3)
```

```sh
3
10
5
16
8
4
2
1
```

いろいろな数字を入れて、すべて最終的に1になることを確認せよ。収束するまでの手続きが長い数を探せ。例えば27を入れたらどうなるか。

### 課題2

Collatz問題をグラフで可視化してみよう。新しいノートブックを開き、以下のプログラムを4つのセルにわけて入力せよ。

```py
from graphviz import Digraph
import IPython
```

```py
def collatz(i, edges):
    while (条件1):
        j = i
        if (条件2):
            i = i // 2
        else:
            i = i * 3 + 1
        edges.add((j, i))
```

```py
def make_graph(n):
    g = Digraph(format='png')
    edges = set()
    for i in range(1, n+1):
        collatz(i, edges)
    for i, j in edges:
        g.edge(str(i), str(j))
    g.graph_attr.update(size="10,10")
    g.render("test")
```

```py
make_graph(3)
IPython.display.Image("test.png")
```

成功したら、いろんな数字を`make_graph`に入れて実行してみよ。20ぐらいがちょうどよいと思うが、27に挑戦してもよい。
Collatz予想とは、このグラフが木構造、つまりループ構造が無いことを主張する。

### 課題2A

Collatz予想には様々な変種がある。例えば、

* 何か正の整数を考えよ
* それが偶数なら2で割れ
* それが奇数なら3倍して **3** を足せ
* 以上の処理を数字が **1か3** になるまでずっと繰り返せ

というものである。これもやはり有限回の手順で止まるらしい(おそらくこちらも未解決問題)。これを確認してみよう。

まず、先程課題2で作成した課題に名前をつけて保存しよう。ファイルメニューから「名前を変更」をクリック、もしくは上の「Untitled.ipynb」をクリックし、「collatz.ipynb」と名前を変えよう。
その後、「ファイル」メニューの「保存」を選ぶと保存される。

この状態で「ファイル」メニューから「ドライブで探す」をクリックせよ。「マイドライブ」の「Colab Notebooks」に「collatz.ipynb」があるはずである。
それを右クリックし「コピーを作成」を選ぶと「collatz.ipynbのコピー」というファイルが作成されるので、それを右クリックして「名前を変更」を選び、
「collatz2.ipynb」という名前にしよう。「collatz2.ipynb」が作成されたら、右クリック→「アプリで開く」→「Colaboratory」を選ぶことで開くことができる。

「collatz2.ipynb」がGoogle Colabで開かれたら、

* 数字が1か3になったら終了とする
* 奇数だったら3倍して3を足す

となるように修正せよ。

修正したら、例えば`make_graph(5)`として、1に収束する数字と3に収束する数字があることを確認せよ。
`make_graph(50)`ではどうなるか？1に収束するのはどういう数字か？

## 余談：バグについて

プログラムが何か意図しない動作をする場合、その原因となる箇所を「バグ」と呼ぶ。バグの語源については諸説あるようだが、詳しいことはわからない。
「i」と「l」と「1」など、似ている文字を誤入力してしまったり、考慮すべきケースを忘れていたり、バグの原因は様々である。
単純なバグについては、コンパイラや検査ツールの充実、テスト手法の向上などにより事前に検出できるようになってきた。
そんななか、未だによく見かけるバグに「オーバーフロー/アンダーフローバグ」がある。コンピュータが扱える数字には上限がある。
たとえば整数は32ビットで表現されることが多い。符号無し整数の場合、表現できる最大の数は4294967295、つまり43億ちょっとである。
符号付きの場合は、符号に1ビット使うので最大の数はその半分になる。
この数字を超える、すなわち最大値を取っている変数に1を足すと、またゼロに戻ってしまう。オーバーフローバグは、よくタイマー周りに潜む。
最近だと、ボーイング787という飛行機の電源制御システムが、連続して248日動作させると不具合を起こすことが報告された。
慣れたプログラマなら、「248日」と聞いた瞬間に「あ、オーバーフローやったな」と気がつく。
248日とは21427200秒である。31ビットで表現できる最大の数は2147483647であるから10ミリ秒を単位に動作する31ビットのクロックが、
248日でオーバーフローしたと考えられる。同根のバグに「497日問題」とか「49.7日問題」があるので、興味があれば調べられたい。

オーバーフローとは逆に、値が0になってるのに引き算をして、値が逆に大きくなるバグもあり、アンダーフローバグと呼ばれている。
アンダーフローバグで有名なのは「突然キレるガンジー」であろう。
Cibilizationという、文明を発展させるゲームがある。歴史上の有名人をプレイヤーとして選び、
世界制覇などを目指すゲームである。この中のプレイヤーにガンジーがいた。
ガンジーは「非暴力、不服従」の提唱者であり、平和主義者なのであるが、文明がある程度発展すると
突如として核攻撃をしかけてくるようになる。これはアンダーフローバグであった。
Cibilizationでは各プレイヤーには攻撃性が設定されており、
文明が民主主義を採用すると攻撃性が2下がる、という仕組みがあった。
さて、ガンジーの攻撃性は1なのだが、インド文明が民主主義を採用し2を引くと-1になる。
しかし、攻撃性は「符号なし8ビット整数」で表現されていたため、1から2を引くと攻撃性最大の255になってしまった。
こうして「突然キレるガンジー」が誕生したのである。

整数の表現できる数値に最大値があることに起因するバグは根深く、発見が難しい。
かくいう私も、4294967295回に一度意図しない動作をするというエグいバグを入れたことがある。
43億回に一度発生するため、研究室のPCでは再現せず、スパコンを使ったときにたまに発生する、という感じだったので
原因究明に時間がかかった。バグという概念が生まれてかなりの時間がたったが、まだ人類はバグを根絶できていない。
それなら僕がバグを入れるのもやむを得まい(言い訳である)。

参考：[オーバーフローが引き起こした面白いバグの話](https://note.mu/ruiu/n/n89d18450b1bb)