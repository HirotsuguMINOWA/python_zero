# 第二講

## 本講で学ぶこと

* 繰り返し処理
* 関数の宣言と利用方法
* プログラムがなぜ、どのように動作するか

## 組み込み型

Pythonに限らず、プログラム言語には「型 (type)」がある。「型」とは、そのデータが何を表現しているかを表すものである。
「型」は自分で作ることもできるが、言語にもともと備わっている型もあり、それを「組み込み型 (Built-in types)」と呼ぶ。

### 真偽値

「真(True)」であるか「偽(False)」であるかの二値だけを取る型です。比較や論理演算ができる。
条件分岐などで使われる。

```py
True #=> True
False #=> False
True and False #=> False
True or False #=> True
not True #=> False
not False #=> True
```

### 整数

「1」「2」「3」といった整数を表現する。四則演算や比較などができる。負の数も扱える。

```py
1 # => 1
1 + 2 # => 3
2 * 6 # => 12
2 - 5 # => -3
```

整数同士を比較すると真偽値になる。

```py
1 == 1 #=> True
1 == 2 #=> False
1 != 1 #=> False
1 != 2 #=> True
1 < 2  #=> True
1 > 2  #=> False
```

### 浮動少数点

「0.1」「123.45」といった、整数ではない値を表現する。整数と同様に四則演算や比較ができるし、負の数も扱える。

```py
0.5 + 0.5 #=> 1.0
0.5 * 0.5 #=> 0.25
0.5 < 1.0 #=> True
```

ただし、浮動小数点数は内部的には **その数値に最も近い近似値** を扱っているため、誤差が存在する。例えば0.1を3回足しても0.3にならない。

```py
0.1 + 0.1 + 0.1 #=> 0.30000000000000004
0.1 + 0.1 == 0.2 # => True
0.1 + 0.1 + 0.1 == 0.3 #=> False
```

したがって、** 浮動小数点数同士の等号比較は信頼できない **。浮動小数点数同士の等号比較は、意図通りに動作したりしなかったりする。
初心者がよく入れるバグなので注意すること。

整数と浮動小数点数の演算結果は、(たとえ結果が整数になろうとも)浮動小数点数になる。

```py
0.5*2 #=> 1.0
```

### 整数の除算と余り

整数同士の割り算は(たとえ演算結果が整数であろうとも)浮動小数点数になる。

```py
6/3 #=> 2.0
```

もし、整数の割り算で整数を得たい場合(商を求めて余りを無視したい場合)は`//`を用いる。

```py
6//3 # => 2
5//2 #=> 2
```

整数の割り算で余りが欲しい場合は`%`を用いる。

```py
6%3 #=> 0
5%2 #=> 1
```

### 複素数

Pythonは複素数も扱うことができる。虚数単位がjなので注意。実部、虚部は`real`、`imag`で取り出すことができる。
また、整数で記述しても浮動小数点数として扱われることに注意。

```py
1 + 2j # => (1+2j)
(1+2j) + (2+4j) #=> (3+6j)
(1+2j)*(1-2j) => (5+0j)
(1+2j).real #=> 1.0
(1+2j).imag #=> 2.0
```

## 変数

プログラム言語では、値にラベルをつけることができる。そのラベルは、値として振る舞う。このラベルを「変数 (variable)」と呼ぶ。

```py
a = 1
print(a) # => 1
a + 1 #=> 2
```

値は演算結果で上書きすることができる。

```py
a = 1
print(a) # => 1
a = a + 1
print(a) # => 2
```

## 関数

Pythonでは、よく使う処理を「関数」という形で定義し、何度も利用することができる。

```py
def sayhello():
  print("Hello!")
```

定義した関数は後で何度でも呼ぶこともできる。

```py
sayhello() #=> "Hello!"
```

関数にインプットを与えることもできる。このインプットを「引数(ひきすう)」と呼ぶ。

```py
def say(s):
  print(s)
```

```py
say("Bye!") #=> Bye!
```

関数を実行した結果、値を返すこともできる。返す値は`return`文で指定する。

```py
def add(a, b):
    return a + b
```

```py
add(3, 4) #=> 7
```

関数が返した値を変数に代入することもできる。

```py
a = add(1, 2)
print(a) #=> 3
```

## Collatz問題

まずはプログラムを作ってみよう。題材としてCollatz問題を取り上げる。
Collatz問題とは、以下のようなものである。

* 何か正の整数を考えよ
* それが偶数なら2で割れ
* それが奇数なら3倍して1を足せ
* 以上の処理を数字が1になるまでずっと繰り返せ

たとえば「5」を考えよう。これは奇数なので3倍して1を足すと「16」になる。
これは偶数だから2で割って「8」、さらに2で割って「4」「2」「１」となる。

Collatz問題とは「すべての整数について有限回の手続きで1になるか？」というものであり、現在も解決されていない。
もし有限の手続きで1にならないとしたら、どこかに無限に大きくなるか、ループする構造があるはずだが、今の所どちらも見つかっていない。

### 課題1

与えられた数字に対して、

* 偶数なら2でわる
* 奇数なら3倍して1を足す

という処理を、その数字が1になるまで繰り返しながら表示する関数`collatz`を作りたい。
以下の空欄を埋めよ。

```py
def collatz(i):
  print(i)
  while [条件1]:
    if [条件2]:
      i = i //2
    else:
      i = i * 3 + 1
    print(i)
```

インデントに注意。最初の`print`と二番目の`print`はインデントの位置が異なる。

完成したら、関数を入力したセルを実行してから、別のセルに以下のように関数呼び出しを入力、実行し、結果が一致することを確認せよ。

```py
collatz(3)
```

```sh
3
10
5
16
8
4
2
1
```

いろいろな数字を入れて、すべて最終的に1になることを確認せよ。収束するまでの手続きが長い数を探せ。例えば27を入れたらどうなるか。

### 課題1A

Collatz問題をグラフで可視化してみよう。新しいノートブックを開き、以下のプログラムを4つのセルにわけて入力せよ。

```py
from graphviz import Digraph
import IPython
```

```py
def collatz(i, edges):
    while [条件1]:
        j = i
        if [条件2]:
            i = i // 2
        else:
            i = i * 3 + 1
        edges.add((j, i))
```

```py
def make_graph(n):
    g = Digraph(format='png')
    edges = set()
    for i in range(1, n+1):
        collatz(i, edges)
    for i, j in edges:
        g.edge(str(i), str(j))
    g.graph_attr.update(size="10,10")
    g.render("test")
```

```py
make_graph(3)
IPython.display.Image("test.png")
```

成功したら、いろんな数字を`make_graph`に入れて実行してみよ。20ぐらいがちょうどよいと思うが、27に挑戦してもよい。