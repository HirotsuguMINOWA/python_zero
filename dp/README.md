# [動的計画法](https://kaityo256.github.io/python_zero/dp/)

## 本講で学ぶこと

* 組み合わせ最適化問題
* 動的計画法の要点
* 貪欲法
* メモ化再帰
* 漸化式とループ
* 余談：人外について

## 組み合わせ最適化問題

これまで、どこかで「ナップサック問題」という言葉は聞いたことがあるだろう。あなたは洞窟の奥で見事宝物庫を見つけた。そこには重さと価値がまちまちな「宝物」が多数あるが、持ち帰ることができる重さには上限がある。この時、決められた重さの中で価値を最大化するにはどうすればよいだろうか？というのがナップサック問題である。

![ナップサック問題](fig/knapsack.png)

このような「たくさんの物のセットが与えられ、何かの条件(ここでは重さの総和)を満たしつつ、何かの価値を最大化するような組み合わせを探す」という問題は、「組み合わせ最適化問題」と呼ばれる。ナップサック問題は典型的な組み合わせ最適化問題の一つである。

あまり意識していないかもしれないが、我々は日常的に組み合わせ最適化問題を解いている。例えばレストランでメニューを見ながら何を食べるか決める時、当然ながら美味しいものを食べたいと思うことであろう。しかし、美味しい物は一般に値段もカロリーも高いというのがこの世の摂理である。そこで、「ある程度の予算、カロリーの制限内で、一番幸せ度が高いメニューの組み合わせ」を探すことになる。これは典型的なナップサック問題である。

何か作業をする際、目の前にタスクが一つしかない、ということは少ないであろう。多くの場合、多数のタスクがそれぞれ依存関係を持っており、それらは最終的にはすべて片付けないといけないのだが、取り組む順番によってはコストが大きく変わる、ということもよくある。

例えばあなたは

* スーパーで食材の買い物をする
* 郵便局で封筒を簡易書留で出す
* 借りていた本を図書館に返しに行く

という三つのタスクをこなす必要がある。実行順序は自由だ。簡単のため、スーパー、図書館、郵便局は家から等距離にあるとしよう。どのような順番でタスクをこなすべきだろうか？

もし「スーパー」「郵便局」「図書館」という順序でタスクをこなすと、あなたは「重い本を持ちながらスーパーで買い物をして」「スーパーで購入した食材と本を持ちながら郵便局に行き」「最後に本を返す」ということになり、手が疲れてしまう。この場合は「図書館」「郵便局」「スーパー」の順番が良いだろう。まずは重い本をなんとかし、荷物が軽い状態で郵便局のタスクをこなし、最後に食材を買って帰れば、疲れは最小限で済む。

あなたは旅行を計画している。目的値に到着するのに、複数の経路があるのだが、できるだけ早く、もしくはできるだけ安く到着したい。どのような経路を取ればよいだろうか？いま、この経路をグラフで表現してみよう。

![最短経路問題](fig/shortestpath1.png)

いま、A地点からI地点までいきたい。そのための経由地(例えば電車の駅だと思えばよい)がBからHまである。それぞれの地点間にはコストが定義されている。この場合のコストは時間もしくは料金である。

このように、我々は日常的に「何かの条件を満たしつつ、何かを最適化する」という問題に直面している。しかし、これらの問題の多くは「最適解」を得ることが難しい「NP困難 (NP-hard)」な問題であることが多い。「NP困難」については深く立ち入らないが、ようするに「最適解を得るには全ての組み合わせを調べるしかなく、要素数が増えると計算時間が爆発してしまう」という問題のことである。このような問題は、応用上は必ずしも厳密解を得る必要はなく、近似解が求まればそれで十分な場合も多いため、高速に近似解を求める手法も数多く提案されている。

しかし、ある種の組み合わせ問題は効率的に解くことができる。その際に使われる手法が本講で紹介する「動的計画法」である。

## 動的計画法の要件

「動的計画法」という、難しそうな名前がついているが、そのアルゴリズムの骨子はさして難しくない。動的計画法が適用できる条件は、以下の二つである。

* 大きな問題を、より小さな問題に分解できること (分割統治)
* 分解された小さな問題の結果が、再利用可能であること (メモ化)

例を挙げよう。先程の最短経路探索問題の回答は、以下のようなものだ。

![最短経路](fig/shortestpath2.png)

A→B→E→C→F→H→I

この時、最短経路は13になる。さて、この経路をよく見てみよう。いま、最短経路がこのように定まったとしよう。AからEを経由してIに到達している。この時、「AからE」への経路も最短であり、「EからI」への経路も最短となっている。

![部分経路の最短性](fig/shortestpath3.png)

このように、最短経路問題は「もし最短経路が求まったのなら、その途中の任意の二点間の経路も最短である」という性質をもっている。もしこの性質が満たされていないとしよう。例えば上記では、「AからE」の最短経路のコストは3であり、「EからI」の最短経路のコストは10、あわせて「AからI」へのコストは13となっている。もし「AからE」に、コスト2以下のパスがあるならば、そちらを採用すれば、「AからI」のコストを下げることができる。これは「AからIへの最短経路が求まった」という条件と矛盾する。以上から「最短経路の任意の二点間の経路も最短である」ことがわかる。

![部分問題が解けている時の「最後の仕上げ」](fig/shortestpath4.png)

これがどのように問題を解くのに使えるか考えてみよう。いま知りたいのは「AからI」までの最短経路である。しかし、それより小さい問題、「AからG」までの最短経路と、「AからH」までの最短経路がわかっているものとしよう。それぞれ「A-G」のコストが13、「A-H」のコストが11である。すると、「GからI」のコストが1、「HからI」のコストが2であることがわかっているので、AからG経由でIに行く最短パスのコストは14、AからH経由でIに行くコストは13となり、A-H-Iの経路が最短であることがわかる。

こうして、「問題が部分的に解けている」ならば、それを「再利用」することでより大きな問題が解けるでしょう、というのが動的計画法の骨子である。

## サイゼリヤ問題

### サイゼリヤ問題とは

「レストランでどのメニューを頼むか悩む」のが、組み合わせ問題の一種であることを述べた。実際に最適化したいのは「幸せ度」であるが、「幸せ度」を定量化するのは難しいため、ここでは「一定の予算内で、摂取カロリーを最大化するメニュー」を探してみよう。ただし、同じメニューを重複して注文してはいけないことにする。

サイゼリヤのメニューは日々変わっているが、ここではある時点でのメニュー、114品の金額とカロリーのデータを使って、「サイゼリヤに1000円を握りしめていったら、最大何kcalを摂取できるか」という問題を解いてみよう。

### データの読み込み

まずはデータを読み込んでみよう。新しいノートブックを開き、いつも通り最初のセルで必要なものをimportする。

```py
import pickle
from collections import defaultdict
```

次に、データをロードしよう。二つ目のセルに以下を入力する。

```py
FILE='https://kaityo256.github.io/python_zero/samples/saizeriya/saizeriya.pickle'
!wget $FILE
```

最後に`‘saizeriya.pickle’ saved [5293/5293]`と表示されれば成功だ。これはpickleというライブラリでシリアライズされたデータである。読み込んでみよう。三つ目のセルに以下を入力せよ。

```py
with open('saizeriya.pickle', 'rb') as f:
    names, prices, cals = pickle.load(f)
```

これは、114種類のメニューそれぞれの、名前、価格、カロリー(kcal)のリストである。読み込めたら、4つ目のセルで、例えば`names`を評価してみよ。`「['彩りガーデンサラダ', '小エビのサラダ',,,'コーヒーゼリー','トリフアイスクリーム']`と表示されれば正しく読み込めている。確認できたら4つ目のセルは消しておくこと。

### 貪欲法

さて、動的計画法を組む前に、まずは近似解を求めてみよう。組み合わせ最適化の近似解を求める方法はたくさんあるが、その中でも一番簡単な「貪欲法(Greedy Method)」を紹介する。

ナップサック問題において、ある重さ以内で最大の価値を得たいのだから、最終的には「重さあたりの価値」を最大化していることになる。したがって、一つ一つの品物についても、「重さあたりの価値」が高いものを選びたくなるであろう。これをサイゼリヤ問題に当てはめると「値段あたりのカロリー」が高いものから順番に選び、予算を超えたらそこでストップ、というアルゴリズムが考えられる。アルゴリズムとしては以下のようになる。

* メニューを「値段あたりのカロリー」で降順にソートする
* ソートした結果を上から順番に注文していく。ただし、予算オーバーするなら次を試す
* 全てのメニューを調べたら終了

プログラムは以下のようになる。

```py
def greedy(budget):
  ind = list(range(len(names)))
  ind = sorted(ind, key=lambda x: cals[x]/prices[x], reverse=True)
  psum = 0
  csum = 0
  for i in ind:
    if psum + prices[i] >= budget:
      continue
    psum += prices[i]
    csum += cals[i]
    print("{} {}Yen {} kcal".format(names[i], prices[i], cals[i]))
  print("Total {} Yen, {} kcal".format(psum,csum))
```

ここで、

```py
  ind = list(range(len(names)))
  ind = sorted(ind, key=lambda x: cals[x]/prices[x], reverse=True)
```

が、「メニューを価格あたりのカロリーでソートする」部分である。`list(range(len(names)))`は`[0,1,2,...,113]`という連番のインデックスを持つリストを作る部分である。このインデックスを、ある基準`key`でソートするようラムダ式で指定している。ラムダ式というと難しく聞こえるが、要するに

```py
lambda x: cals[x]/prices[x]
```

とは、「x」という値が与えられたら、`cals[x]/prices[x]`を返しなさい、と言っているだけで、

```py
def key(x):
    return cals[x]/prices[x]
```

を一行で書いただけである。これにより、「値段あたりのカロリー」でソートできるが、`sorted`はデフォルトで昇順にソートするため、降順にするために`reverse=True`を指示している。

早速実行してみよう。次のセル(5つ目になるはず)で、以下を実行せよ。

```py
%%time
greedy(1000)
```

さいしょの`%%time`は「実行時間を計測せよ」という意味だ。
以下のような表示がでるはずだ。

```sh
ラージライス 219Yen 454 kcal
アーリオ・オーリオ(Wサイズ) 574Yen 1120 kcal
ポテトのグリル 199Yen 366 kcal
Total 992 Yen, 1940 kcal
CPU times: user 584 µs, sys: 0 ns, total: 584 µs
Wall time: 2.58 ms
```

後にわかるが、これは実は厳密解に一致する。経験的に、よほど条件が込み入ってない限り貪欲法はわりと良い結果を与える。貪欲法の計算量は、メニューの数をNとして、ソートに$O(N \log N)$、そのあとのチェックに$O(N)$なので、全体で$O(N \log N)$である。何か難しそうな最適化問題に直面した場合、動的計画法その他を使う前に、まずは貪欲法を試す、という癖をつけておくとよい。

ちなみに「一万円を握りしめてサイゼリヤにいったら、最大何kcalを摂取できるか」も考えてみよう。先ほどの1000を10000にするだけである。結果はこうなる。

```sh
Total 9960 Yen, 17004 kcal
CPU times: user 3.17 ms, sys: 22 µs, total: 3.2 ms
Wall time: 3.48 ms
```

貪欲法は「1万円なら17004kcal摂取できる」と言ってきた。さすがにこれは厳密解からずれるが、わりと良い線いっていることが後でわかる。また、実行時間も十分短い。

### 全探索

では、いよいよ動的計画法を実装しよう。動的計画法は、大きく分けて「メモ化再帰」と「漸化式＋ループ」の二つの実装方法がある。まずは「メモ化再帰」で実装する。

「メモ化再帰」は、簡単に言えば「再帰で組んだ全探索コードにメモ化というテクニックをつけたもの」だ。そこで、まずは再帰で全探索コードを書こう。

いま、メニューが114個ある。全てのメニューについて「注文する/しない」を選ぶと、全体で$O(2^N)$の手間がかかる。ただし、すでに予算を超えている時に、さらに追加でメニューを注文する必要はないので、その部分は枝刈をする。

![再帰による全探索](fig/fullsearch.png)

これをナイーブに再帰で書いてみよう。`n`番目までのメニューを使って、`budget`円以内で得られる最大のカロリーを返す関数`search(n, budget)`を、以下のように定義しよう。

```py
def search(n, budget):
  if n < 0:
    return 0
  c1 = 0
  if prices[n] <= budget:
    c1 = cals[n] + search(n-1, budget - prices[n])
  c2 = search(n-1, budget)
  cmax = max(c1,c2)
  return cmax
```

再帰の最初に書くのは終端処理だ。ここでは`n`を減らしながら再帰するので、`n < 0`になったら終了としている。

次に、`n`番目のメニューを注文するか、しないかで二通りに分岐しながら再帰する。もし、`n`番目のメニューの値段が、現在の予算の範囲内であれば、それを採用した場合のカロリーは

```py
c1 = cals[n] + search(n-1, budget - prices[n])
```

で得られる。ここで、`search(n-1, budget - prices[n])`は、「`n-1`番目までのメニューを使って、`budget-prices[n]`円で得られる最大カロリー」を返してくれるはずである。

また、n番目のメニューを注文しなかった場合は、そのメニューのカロリーが得られないかわりに、予算も減らないので、得られるカロリー`c2`は

```py
c2 = search(n-1, budget)
```

で得られる。動作としてはトーナメントをイメージすればよい。各試合で、追加してきたメニュー同士で戦う。予算オーバーしたら失格、両者予算内なら、カロリーが多い方が勝ちである。これで最後まで勝ち残ったメニューが、予算内で最大のカロリーとなるはずだ。

実際に実行してみよう。

```py
%%time
search(113,1000)
```

実行結果はこうなるはずだ。

```sh
CPU times: user 6.41 s, sys: 0 ns, total: 6.41 s
Wall time: 6.42 s
1940
```

最大カロリーは1940kcalであり、貪欲法と一致した。これは全探索しているので厳密解だ。ただし、実行時間が6秒と、かなりかかっている。

なお、ここで求められるのは最大カロリーだけである。最大カロリーが求まった時、それを与えるメニューの組み合わせを求める方法は後述する。

### メモ化再帰

先ほどの全探索コードは、予算が増えるにしたがって指数関数的に時間がかかるので実用的でない。例えば1000円の予算を1200円にするだけで、6秒が44秒になってしまう。これを改善しよう。

ポイントは`search(n, budget)`の返す値は同じ`n`と`budget`の組み合わせについては同じ値を返す、ということである。特に`n`や`budget`が小さいところでは、同じ組み合わせが何度も呼ばれているため、それを毎回計算するのは無駄だ。そこで、一度計算した`(n, budget)`の組み合わせは、再利用することにしよう。やり方は簡単で、辞書を使うだけである。先ほどの`search`関数を定義しているセルを、以下のように修正せよ。

```py
dic = defaultdict(int)   # 追加(1)
def search(n, budget):
  if n < 0:
    return 0
  if dic[(n, budget)] is not 0: # 追加(2)
    return dic[(n, budget)]     # 追加(2)
  c1 = 0
  if prices[n] <= budget:
    c1 = cals[n] + search(n-1, budget - prices[n])
  c2 = search(n-1, budget)
  cmax = max(c1,c2)
  dic[(n, budget)] = cmax # 追加(3)
  return cmax
```

先ほどの関数に、4行追加しただけだ。最初の追加(1)は、辞書の定義である。

```py
dic = defaultdict(int)   # 追加(1)
```

普通に辞書を作ると、存在しないキーを与えるとエラーとなるが、`defaultdict`は、キーが存在しなかった場合には、デフォルトの値を返すような辞書を作ってくれる。`defaultdict(int)`は、デフォルトの値として0を返す辞書を作って返す。

次に、「もしすでに調べた`(n, budget)`の組み合わせなら、計算済みの値を返す」という再帰の終端条件を追加している。

```py
  if dic[(n, budget)] is not 0: # 追加(2)
    return dic[(n, budget)]     # 追加(2)
```

ここで、`n`と`budget`をまとめたタプル`(n, budget)`を辞書のキーとしている。

もし計算したことがない組み合わせなら、そのまま計算するが、せっかく計算したので、それを最後に覚えておく。

```py
  dic[(n, budget)] = cmax # 追加(3)
```

これは`(n, budget)`の組み合わせで得られる最大カロリーを、辞書`dict`に登録するコードだ。まるでメモを取っているようなので「メモ化 (Memoization)」と呼ぶ。メモ化は実装が簡単なわりに極めて効果的な高速化テクニックである。ここでメモした値が、先ほどの「追加(1)」で使われる。

さて、早速実行してみよう。まずは予算1000円から。

```py
CPU times: user 94.1 ms, sys: 1.01 ms, total: 95.1 ms
Wall time: 99.4 ms
1940
```

実行時間が6秒から0.1秒になった。特筆すべきは、実行時間の予算依存性である。全探索の場合は1000円を1200円にするだけで計算時間が7倍になった。しかし、メモ化を施した再帰ルーチンなら、10000円でも実行可能だ。

```py
%%time
search(113,10000)
```

実行結果は以下のようになる。

```py
CPU times: user 1.84 s, sys: 34.5 ms, total: 1.87 s
Wall time: 1.87 s
17048
```

問題サイズは10倍になったが、2秒で計算が終わっている。ちなみに、このセルをもう一度実行すると一瞬で終わる。

```py
CPU times: user 34 µs, sys: 0 ns, total: 34 µs
Wall time: 38.1 µs
17048
```

先ほどの実行で`(n=113, budget=10000)`の組み合わせの調査結果がメモされており、それをただ返してきたためだ。

このコードは基本的に全探索コードなので、得られる値は厳密解である。先ほど貪欲法で得られた答えは、1万円の予算で17004 kcalであった。厳密解は17048 kcalである。誤差わずか0.26%である。このように、「素直な問題」に対しては、貪欲法は良い近似解を与えることが多い。なお、何が「素直な問題」かはここでは深入りしない。

### 課題1：解の再構成

さて、メモ化再帰により、「ある予算内で得られる最大カロリー」はわかったが、「その最大カロリーを与えるメニュー」はわからない。しかし、先ほどメモしたリストと、最大カロリーがわかれば、そのメニューを構成するのは簡単である。

探索が終わったら、`dic[(n, budget)]`には、`n`番目のメニューまでを使って、予算`budget`内で得られる最大のカロリーがメモされているはずだ。再帰コードをもう一度見ると、この辞書が更新されるのは、メニュー`n`が注文されるか、されないかの二通りのどちらかだ。

```py
# メニューnが注文される時
dic[(n, budget)] = cals[n] + search(n-1, budget - prices[n])

# メニューnが注文されない時
dic[(n, budget)] = search(n-1, budget - prices[n])
```

今、`n`番目のメニューまで使って、予算`budget`で最大`cal`カロリーが得られるとわかっているとしよう。このカロリー最大化メニューに`n`番のメニューが含まれているならば、

```py
cal = cals[n] + dic[(n-1, budget-prices[n])]
```

が成立しているはずである。従って、メニューを最後から順番にまわして、上記の条件が成立していたら`n`をメニューに追加して、予算とカロリーを減らし、そうでなければ次を探す、というループを回せばよい。それをそのまま実装したのが以下の関数である。

```py
def get_menu(budget, cal):
  menu = []
  for n in reversed(range(len(names))):
    if cal is 0:
      break
    # ここを実装せよ
  return menu
```

上記のコードの「ここを実装せよ」の箇所に、

* もし`cal = cals[n] + dic[(n-1, budget-prices[n])]`が成立していたら
* `cal`から`cal[n]`を引き、
* `budget`から`prices[n]`を引き、
* `menu`に`n`を追加する

コードを記述せよ。

この関数が、「カロリー最大化メニュー」のインデックスリストを返す。正しく実装できていれば、以下のように実行すれば以下のような出力が得られるはずである。

```sh
[100, 72, 24]
```

このメニューインデックスリストを受け取って、名前やカロリーを表示するコードも書こう。

```py
def show_menu(menu):
  for i in menu:
    print("{} {} Yen {} kcal".format(names[i], prices[i], cals[i]))
  total_price = sum(map(lambda x: prices[x], menu))
  total_cal = sum(map(lambda x: cals[x], menu))
  print("Total {} Yen {} kcal".format(total_price, total_cal))
```

上記二つをまとめて実行してみよう。

```py
menu = get_menu(1000, 1940)
show_menu(menu)
```

以下のような実行結果が得られるはずだ。

```sh
ラージライス 219 Yen 454 kcal
アーリオ・オーリオ(Wサイズ) 574 Yen 1120 kcal
ポテトのグリル 199 Yen 366 kcal
Total 992 Yen 1940 kcal
```

同様に、予算一万円の場合のメニューも調べてみよう。

```py
menu = get_menu(10000, 17048)
show_menu(menu)
```

実行結果は以下の通り(途中のメニューリストは省略するが、是非自分の目で確認して欲しい)。

```sh
Total 10000 Yen 17048 kcal
```

なんと1万円ぴったりである。成人男性が一日に摂取するカロリーが2000 kcalだそうなので、ざっくり25人前の食事ということになる。一人前あたり400円である。この値段をどう思うかは読者の評価に任せよう。

### 漸化式＋ループ

TODO: 漸化式＋ループ法をやる？

## 余談：人外について

「人外」という言葉がある。「じんがい」と読む。同様に「人ではない」ということを意味する「非人」が侮蔑的な意味を持つことが多いのとは異なり、主にファンタジーなどの世界において、獣人や精霊、妖精など、人としての外見を持つが、基本的に人よりも高次の存在を「人外」と呼ぶことが多い。世界観にもよるが、基本的に「人外」は人間より優れた能力
を持ち、通常の人間が敵う相手ではない、強大な存在として描かれることが多い。いつの頃からか、この「人外」という言葉が「同じ人間とは思えないような、卓越した成果を挙げている人間」を指すようになった。僕は、さらに意味が特化させ「同じ人とは思えないプログラム能力を持つ存在」として使っている。この意味での用例の初出がどこかはわからない。おそらく「競技プログラム」界隈から言われるようになったのではないかと思われる。

本稿の読者は大学生を想定しているが、20年近く生きていれば、「あ、こいつには絶対にかなわない」というような、才能の差を感じて絶望したことが一度や二度はあるであろう。おそらく君たちの二倍以上生きている筆者も、自慢じゃないがこれまでなんども「才能の差」に絶望してきた。特に「プログラミング」は、「できる人」と「できない人」の差が極めて大きく開く分野である。定義にもよるが、「できる人」と「できない人」の生産性はかるく桁で変わってしまう。そして、「この人、本当に人間なんかいな」という「人外プログラマ」の作るものを目の当たりにして驚嘆し、自分と比較して絶望し、その後に達観するのである。

我々一般人は、普通に生きていれば「人外」とぶつかる可能性は低い。むしろぶつからないように生きるのが正しい道である。しかし、何かとちくるって、一般人であるにもかかわらず「世界一になりたい」という野望を抱いてしまうと不幸である。なんでもよいが、何かの処理の最速、世界一を目指すと、極めて高確率で「人外」とぶつかる。人外は、その絶対数が少ない希少種である。しかし、何か数値化され、「世界一」が客観的に定義できる場所には(それがどんなにマイナーな分野であっても)必ず生息している。世界一になるためには、彼らに勝たなければいけない。ファンタジーでの定番、圧倒的な存在である人外をどうやって人間が討伐するか、という問題図式である。

ではどうすればいいのか？　まだどの分野でも世界一になったことがない僕は、もちろんその答えを持っていない。
