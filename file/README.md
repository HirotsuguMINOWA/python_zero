
# [ファイル操作](https://kaityo256.github.io/python_zero/file/)

* ファイルシステムについて
* ファイルの読み込み
* CSVファイルの扱い
* データ解析

## ファイルシステム

### ファイルとは何か

Pythonなどのスクリプト言語を使えるようになると、使えない場合に比べて飛躍的に作業効率が上がる。特に、大量のファイルを解析、変換したいといったケースで、一つ一つエクセルで開いては作業する人に比べて、Pythonその他スクリプト言語とシェルスクリプト等を組み合わせて処理できる人は、生産性に圧倒的な差が出る。そこで、今回はPythonでCSVファイルを開いて、データの解析を行う。しかし、まずその前に「そもそもファイルとは何か」を知っているだろうか？

我々がコンピューターを使う際、何気なくファイルを触っている。スマートフォンで以前撮影した写真を見てみたり、ダウンロードした音楽を聞いたりしている時、意識はしていないかもしれないが、裏ではアプリケーションが写真ファイルや音楽ファイルを開いて読み込み、再生している。また、パソコンで、デスクトップにあるファイルをダブルクリックして開いたり、「あのファイルどこにやったかな」とディレクトリを探し回ったりしたことがあるだろう。スマホでもパソコンでも、何かデータにアクセスする際は、ほとんどの場合においてファイルの読み書きという形をとっている。ファイルの実体は、例えばハードディスクやSDカードに記録されたデータであり、両者は物理的には全く異なるアクセスをしているにも関わらず、保存先がハードディスクであってもSDカードであっても、同じようにアクセスすることができ、我々はその裏で何が起きているのかを意識することはほとんどない。それは、オペレーティングシステムが、「ファイルを管理する」という面倒な作業を代わりにやってくれているからだ。このファイルを管理する仕組みを「ファイルシステム」と呼ぶ。

おそらく、今後の人生でファイルシステムの知識が必要になることはほとんどないであろう。必要になるとしても、せいぜい「SDカードやUSBメモリをフォーマットする時に、ファイルシステムの種類に気を付けないとWindowsとMacで互換性の問題が起きる」といった程度で、ファイルシステムの仕組みや動作について知っていても役に立つことはないと思われる。しかし、役に立つ、立たないは別として、普段使っているパソコンやスマホの裏で、「ファイル」や「フォルダ」がどのような仕組みで管理されているか知っておいても良いであろう。それが教養というものである。

### ファイルシステムとは

我々が普段使うスマホのデータは主にSDカードに保存されている。また、パソコンのデータはハードディスク、もしくはSSDに保存されている。SDカード、ハードディスク、SSDなどを総称してストレージ(storage)と呼ぶ。ストレージは、外部補助記憶装置とも呼ばれ、計算機のデータを長期間保存するためのデバイスである。

これらストレージは、「ブロック」もしくは「クラスタ」と呼ばれる単位でデータを読み書きする。ブロックのサイズはデバイスによって異なるが、おおむね4KB程度である。ストレージには、ブロック単位で通し番号がつけられており、「12番のブロックからデータを読み込む」「488番と489番のブロックにデータを書き込む」といった形でデータの読み書きを行う。もし、これらのストレージを「生のまま」使うならば、ユーザが「どのブロックに何を書き込んだか」をすべて覚えておかなければならない。これは面倒なので、ブロックに「ラベル」をつけたくなるであろう。例えば「0番のブロックにはtest.txtというラベル」、「1番のブロックにはhoge.cppというラベル」といった具合である。この、ブロックに対するラベルの役割をするのがファイル名である。また、ファイルが増えてくると、それをグループ単位で管理したくなる。これがフォルダである。

データが大きい時には、1つのブロックには収まりきらない。例えばブロックのサイズが4KBの時、10KBのデータを保存するには3つのブロックが必要となる。この時、いちいち空いているブロックを探して「4,5,6番のブロックに保存」などと指定するのは面倒である。しかも、ブロック単位で書いたり消したりしているうちに、「空いている(使って良い)ブロック」が不連続になってくる。この時に大きなデータを書き込むためには、一つのファイルをバラバラのデータに分けて保存しなければならない。さらに、そのデータの一部を修正するためには、そのデータのその場所がどのブロックに保存されているかを調べる必要がある。これをすべてが覚えておくのは大変だし、計算機側に自動で管理して欲しいと思うであろう。

このように、ストレージにブロック単位で保存されているデータに、ファイル名やフォルダといった構造を与え、人間にとって扱いやすくするのがファイルシステムである。ファイルシステムには数多くの種類があるが、Linux系ならext4やxfs、WindowsはNTFS、USBメモリなどにはexFATなどがよく使われている。このうち、いま使っているGoogle Colabでも採用されているext4について簡単に説明しよう。なお、WindowsやMacではファイルをまとめて管理する仕組みを「フォルダ」と呼ぶが、Linuxでは「ディレクトリ」と呼ぶため、以後、ディレクトリと呼ぶことにする。細かいことを言い出すときりがないが、とりあえず「フォルダ」と「ディレクトリ」は同じものだと思っておいてよい。また、簡単のため、以下ではかなり説明を省くことに注意(例えばジャーナルの説明や特別なブロックの説明はしない)。

### inode

すでに述べたように、ストレージは「ブロック」という単位でデータの読み書きをする。一つもしくは複数のブロックにまたがって保存されているデータにつけた別名が「ファイル」である。「どのブロックが、どのファイルに所属するか」を記録しているのがinodeと呼ばれるデータだ。全てのファイルには一意なinode番号が割り振られる。inodeには、inode番号、どのブロックを使っているか、ファイルサイズはどれくらいか、所有者は誰かなどの情報が保存されている。inode番号には上限があり、もし使い切った場合は、たとえストレージ容量に余裕があっても新たにファイルを作ることはできない。

![inodeによるファイル管理](fig/inode.png)

ディレクトリもinode番号を持っており、inodeデータとして管理されている。実はinodeはファイル名を保持しておらず、ファイル名はディレクトリが管理している。ディレクトリは、自身が管理するファイルとinode番号の対応表を持っている。Linux系のファイルシステムでは、ディレクトリは「.(ドット)」と「..(ドットドット)」という二つの特別なディレクトリを持つ。それぞれ「自分自身」と「親ディレクトリ」を指している。

なぜファイルを管理するinodeがファイル名を持たず、ディレクトリがファイル名を管理しているのかについては、いくつか理由がある。まず、一つのinodeに複数のファイル名が対応する場合があり、inode番号だけでは、どのファイル名に対応するかがわからない。つまり「ファイル名」から「inode番号」は一意に決まるが、「inode番号」から「ファイル名」は一意には決まらない。この仕組みをハードリンクと呼ぶが、本講義では詳細は扱わない。

もう一つの理由は、素早い検索のためだ。WindowsでもMacでも、あるフォルダをダブルクリックするとそのフォルダが開き、中にあるファイル一覧を見ることができる。もし、inodeがファイル名を管理していると、まずそのフォルダ(ディレクトリ)の直下にあるinode一覧をリストアップし、そのinodeデータそれぞれについてファイル名を読み込みにいかなければならない。つまり、ファイル数の分だけinodeデータにアクセスしなければならず、レスポンスが極めて遅くなる。もしディレクトリがinode番号とファイル名のリストを持っていれば、ディスクアクセス一発で「現在のディレクトリの直下にあるファイル一覧」を得ることができる。これは、今よりもはるかにディスクアクセスが遅かった時代の工夫の名残である。

なお、inodeが管理するようなファイル名や所有者情報、ファイルサイズなどは「メタデータ」と呼ばれる。あるディレクトリ以下にあるファイルをすべて再帰的にリストアップする場合や、名前でファイルを検索する場合など、ファイル操作では「ファイルの中身までは見なくても良い」処理が多い。例えばネットサーフしているときに「ネットが重い」と大変不快なのと同様に、フォルダを開いて中身が表示されるまでに時間がかかると大変不快である。普段あまり意識することは少ないが、メタデータの検索速度はパソコンの「使い勝手」に直結する。

そこで、多くのファイルシステムでは、メタデータを管理する場所とファイルの中身を管理する場所を別々に分け、効率的にメタデータを扱えるように工夫がしてある。スパコンなどで使われるLustreなどの並列ファイルシステムは、メタデータとファイルの中身は別のサーバで管理されており、高速なメタデータアクセスを実現している。

### ファイルのオープン・クローズ

Pythonに限らず、プログラムからファイルを読み書きするには、まずファイルを開く必要がある。「ファイルを開く」とは、「ファイルシステムにファイルの場所を問い合わせて、プロセスからファイルを扱えるように回線をつなぐ」ことである。プログラムは、「プロセス」という形でOSに管理されている。プロセスからOSにファイルへの接続要求があると、OSはファイルシステムにその場所を問い合わせて、プロセスとファイルシステムの間に特別な回線を作って接続する。この回線は「ファイルディスクリプタ」という、内線番号のようなもので管理される。0番から2番までのファイルディスクリプタは特別な回線となっており、それぞれ標準出力、標準出力、標準エラー出力として予約されている。一度ファイルが開かれたら、プロセスはこのファイルディスクリプタを使ってデータを読み書きする。プロセスは同時に複数の回線を保持できるが、回線の数には上限があるため、不要になったら解放する必要がある。そこで、ファイルへの接続が不要になったら、「ファイルを閉じる」必要がある。ファイルを閉じると、回線を破棄し、内線番号(ファイルディスクリプタ)もOSに返却する。その後でファイルを開くと、ファイルディスクリプタは再利用される。

![ファイルオープンの仕組み](fig/fd.png)

なお、この図では省略されているが、実際にはファイル名(test.txt)から、対応するinodeを調べ、そのinodeが指しているブロックを調べ、そのブロックの場所を覚えて、以後の読み書きはそのブロックに対して行う、ということが行われている。

## Pythonでのファイル操作

### Google Colab上でのファイル操作

通常、ファイルの読み書きはローカル(操作しているPCの中)にあるファイルについて行う。しかし我々は今Google Colabというクラウドサービスを使っているため、「ファイルがどこにあるか」「どのファイルを操作しているか」がわかりにくい。Pythonでのファイル操作の説明の前に、まずGoogle Colab上でのファイル操作のイメージについて説明しておこう。

いま、目の前にあるPCはブラウザを実行しており、このブラウザがGoogleのサーバに接続している。

### ファイルを開く、閉じる

Pythonでファイルを開くには`open`関数を用いる。ファイルを開く際、読み込み用として開くのか、書き込み用として開くのか、追記用として開くのかを指示しなければならない。また、扱うのがテキストデータなのか(テキストモード)、それともバイナリデータなのか(バイナリモード)も指定する必要がある。何も指示しない場合にはテキストかつ読み込み用となる。
オプションは以下の文字の組み合わせで指定する。

* 'r' 読み込み用に開く(デフォルト)
* 'w' 書き込み用に開く
* 'a' 追記用に開く
* 't' テキストモード(デフォルト)
* 'b' バイナリモード

以下は例だ。

```py
f = open("filename") # テキストモードかつ読み込み用に開く
f = open("filename","rt") # テキストモードかつ読み込み用に開く(オプションを明示的に指定)
f = open("filename","w") # テキストモードかつ書き込み用に開く
f = open("filename","a") # テキストモードかつ追記用に開く
```

とりあえず本講義ではテキストの読み書きしかしないので、バイナリモードについては説明をしない。

`open`関数はオープンに成功するとファイルオブジェクトを返す。とりあえずこれはファイルディスクリプタを抽象化したものだと思っておけば良い。以後、このファイルオブジェクトを通じてデータの読み書きをするのだが、開いたファイルはいつか閉じる必要がある。開いたファイルを閉じるには、ファイルオブジェクトの`close`を呼び出せばよい。

```py
f = open("filename") # ファイルを開く
f.close() # ファイルを閉じる
```

なお、ファイルを明示的に閉じなかった場合、そのファイルオブジェクトが不要になったタイミングでガーベジコレクション(GC)の対象となる。GCの実装にもよるが、多くの場合、プログラムの終了時にファイルが閉じられる。通常はあまり意識しなくても良いが、同時に開くことができるファイル数には上限があり、それにひっかかるとエラーでプログラムが失敗する。ファイル操作に失敗すると想定外の問題(惨事ともいう)が起きることが多いので、ファイルを開いたら閉じる癖をつけておいた方が良い。

### ファイルの書き込み

ファイルに何か書き込むには、ファイルを書き込み用に開いてから、ファイルオブジェクトの`write`を用いる。

```py
f = open("test.txt","w") # ファイルを開く
f.write("Hello World\n") # 文字列を書き込む
f.close()
```

上記のコードで、「Hello World」と記述された`test.txt`という名前のテキストファイルが作成される。`print`と異なり、`write`は改行が追加されないので、必要な場合は明示的に改行コード`\n`を追加する必要がある。

既に存在するファイルにデータを追記したい場合は、追記モードで開く必要がある。

```py
f = open("test.txt","a") # ファイルを追記用に開く
f.write("This is the second line.\n") # 文字列を書き込む
f.close()
```

上記を実行すると、`test.txt`の内容は以下のようになる。

```txt
Hello World
This is the second line.
```

なお、既に存在するファイルを書き込みモードで開いた場合、その**ファイルを開いただけで内容が消去される**ことに注意。先ほど二行書き込まれたファイルを、ただ書き込みモードで開いて閉じてみよう。

```py
f = open("test.txt","w") # ファイルを書き込み用に開く
f.close() # 閉じる
```

上記を実行すると、`test.txt`の内容は消去され、サイズ0のファイルになる。これは実は書き込み用にファイルを開くと、メタデータの処理によってファイルを削除してしまうからなのだが、ここでは詳細には立ち入らない。ただ、「ファイルを書き込み用に開くと、開いた瞬間にファイルの内容が消える」ということだけ覚えておくと良い。

### ファイルの読み込み

既存のテキストファイルを読み込む場合は、オプションなしの`open`を使えばよい。

```py
f = open("test.txt")
```

その後、`open`が返してきたファイルオブジェクトを使って、ファイル全てを一括して一つの文字列として読み込む`read`、ファイルを全てを一括して読み込み、一行ごとに分割された文字列のリストとして取得する`readlines`、呼び出す度に一行ずつ読み込む`readline`などを使うことでファイルの内容を読むことができるが、各行ごとに何か処理をする場合はファイルオブジェクトに対して`for`文を回すのが一番てっとりばやい。

```py
f = open("test.txt")
for line in f: # ファイルから一行ずつlineに読み込む
    print(line)
```

なお、この形で取得した`line`は、改行コードが含まれているため、それをそのまま`print`で出力すると改行が二つつながり、出力としては「一行おき」に表示されてしまう。それを防ぐには、`line`の末尾の改行を含む空白文字を削除する`rstrip()`を使えばよい。

```py
f = open("test.txt")
for line in f: # ファイルから一行ずつlineに読み込む
    print(line.rstrip())
```

### with構文

ドアを開けたら閉めるように、ファイルを開いたら閉じなければならない。実際には開いたままのファイルはプログラム終了時に閉じてくれるため、ちゃんと閉じなくても問題が起きることは少ないのだが、ファイルを多数開いて、ファイル数の上限に達してしまったり、うっかり開いたままのファイルを別の場所で変にいじっておかしなことになったりと、後々嫌らしい感じの問題を起こすことがあるので、「開いたら閉じる」癖をつけておきたい。といっても、人間のやることなので、ファイルの閉じ忘れを完全に防ぐのは難しい。そこで、Pythonは自動でファイルを閉じてくれる`with`構文、というものがある。

`with`は以下のように使う。

```py
with open("test.txt") as f:
    # ファイルに関する処理
```

`with`の後にファイルを開き、そのファイルオブジェクトを`as`の後の変数で受ける。このファイルオブジェクトは、その後のブロックでのみ有効で、ブロックを抜けるときに自動的にファイルは閉じられる。例えば、テキストファイルを開いて、一行ずつ読み込んでただ表示するだけのコードは以下のように書ける。

```py
with open("test.txt") as f:
    for line in f:
        print(line.rstrip())
```

上記のプログラムでは明示的に`f.close()`は呼び出されていないが、`with`が作るブロックを抜けるときに自動的に`f.close()`が呼ばれ、ファイルが閉じられる。

とりあえず「ファイルを開く時には`with`構文を使う」癖をつけておけば、ファイルの閉じ忘れを防ぐことができるであろう。

なお、`with`構文はファイルだけでなく、例えばデータベースへの接続など「何か定型の前処理や後始末が必要なもの」一般に使うことができる。今後`with`が出てきたら、「ブロックが始まる前に何か前処理をして、ブロックを抜ける時に何か後始末をしているんだな」と思えばよい。

# ファイル操作：課題

## 課題1：ファイルシステムを見てみる

### 課題1-1：ファイルシステムの確認

新しいノートブックを開き、実際にGoogle Colabのファイルシステムがどうなっているかを確認しよう。

#### 1. ファイルシステムの確認

最初のセルに、以下を入力、実行せよ。

```py
! df -T
```

すると以下のような出力が出てくるはずだ。

```txt
Filesystem     Type    1K-blocks     Used Available Use% Mounted on
overlay        overlay  51343840 26636520  22069496  55% /
tmpfs          tmpfs     6667636        0   6667636   0% /dev
...
```

ファイルシステム、`/dev/sda1`の「Type」はどうなっているだろうか？

#### 2. ファイルとinodeの確認

次に、実際にファイルを作成して、そのinode番号を調べてみよう。
2番目のセルに以下を入力、実行せよ。

```py
! touch test.txt
! stat test.txt
```

「test.txt」のファイル情報が表示されたはずだ。「Size」や「Inode」の番号がどうなっているか確認せよ。

#### 3. ディレクトリとinode一覧

現在のディレクトリにあるファイルの一覧とinode番号を確認してみよう。
カレントディレクトリにあるファイル一覧を表示するコマンド`ls`に、inode番号も表示するオプション`-i1`(iの後ろはエルではなくて数字の1であることに注意)を指定してみよう。ついでに`-F`もつけて、ディレクトリであることを明示させる。

```py
! ls -F -i1
```

先ほど作成した`test.txt`と、もともと存在するディレクトリ`sample_data/`が表示され、それぞれの左にinode番号が表示されたはずである。`test.txt`のinode番号が先ほど`stat`で調べたinode番号と一致することを確認せよ。

## 課題2：相関解析

カラーテレビの普及率と、男性の平均寿命の関係を調べてみよう。なお、カラーテレビの普及率データは[内閣府の消費動向調査](https://www.esri.cao.go.jp/jp/stat/shouhi/shouhi.html)から、平均余命のデータは[厚生労働省の参考資料２　平均余命の年次推移](https://www.mhlw.go.jp/toukei/saikin/hw/life/life10/sankou02.html)より取得した。

### 課題2-1: CSVファイルの読み込み

新しいノートブックを開き、以下の順番でセルを入力せよ。

#### 1. ライブラリのインポート

最初のセルに以下のプログラムを書いて実行せよ。

```py
import numpy as np
from matplotlib import pyplot as plt
```

後で使う`numpy`を`np`という別名で、`matplotlib.pyplot`を`plt`という別名で利用することを宣言している。

#### 2. テレビの普及率データのダウンロード

ウェブから、「カラーテレビの普及率データ」のCSVファイルをダウンロードしよう。

```py
!wget https://kaityo256.github.io/python_zero/file/colortv.csv
```

上記を実行すると、ファイルがダウンロードされる。最後に以下のような表示がされたら成功である。

```txt
2019-08-15 11:56:39 (23.7 MB/s) - ‘colortv.csv.1’ saved [162/162]
```

#### 3. テレビの普及率データの確認

ダウンロードしたファイルの内容を確認しよう。以下を実行せよ。

```py
!head colortv.csv
```

`head`コマンドは、ファイルの冒頭(デフォルトで10行)を表示するコマンドだ。以下のような表示になるはずである。

```txt
1966,0.3
1967,1.6
1968,5.4
1969,13.9
1970,26.3
1971,42.3
1972,61.1
1973,75.8
1974,85.9
1975,90.3
```

それぞれの行に、西暦とカラーテレビの普及率の関係が「カンマ」で区切られて記録されている。

実はこのファイルは15行しかないので、`cat`コマンドで全て表示してしまっても良いのだが、大きなファイルの冒頭だけ見たい、といったことがよくあるので`head`コマンドを覚えておくと有用である。同様に、末尾だけ見たい場合のために`tail`コマンドがある。

#### 4. テレビの普及率のプロット

ダウンロードしたデータを読み込んで、横軸を西暦、縦軸をカラーテレビの普及率としてプロットしてみよう。

4つ目のセルに以下を入力、実行せよ。

```py
tv_year = []
tv_data = []
with open("colortv.csv") as f:
  for line in f:
    y, d = line.split(",")
    tv_year.append(int(y))
    tv_data.append(float(d))
plt.scatter(tv_year, tv_data)
```

実行すると、1966年から1980年までのカラーテレビの普及率の推移が表示されるはずである。

#### 5. 平均寿命データのダウンロード

次に5つ目のセルで「男性の平均寿命データ」のダウンロードをしよう。

```py
!wget https://kaityo256.github.io/python_zero/file/lifespan.csv
```

最後に以下のような表示が出たら成功である。

```txt
2019-08-15 11:56:42 (21.5 MB/s) - ‘lifespan.csv.1’ saved [178/178]
```

#### 5. 平均寿命データの確認

先ほどと同様に、`head`コマンドでダウンロードしたデータの中身を確認しよう。

```py
!head lifespan.csv
```

以下のように、カンマで区切られた西暦と平均寿命が記録されているはずである。

```txt
1966,68.35
1967,68.91
1968,69.05
1969,69.18
1970,69.31
1971,70.17
1972,70.5
1973,70.7
1974,71.16
1975,71.73
```

#### 6. 平均寿命のプロット

先ほどと同様に、横軸を西暦、縦軸を平均寿命としてプロットしてみよう。

```py
life_year = []
life_data = []
with open("lifespan.csv") as f:
  for line in f:
    y, d = line.split(",")
    life_year.append(int(y))
    life_data.append(float(d))
plt.scatter(life_year, life_data)
```

寿命が年々伸びている様子がわかるはずだ。

#### 7. テレビの普及率と寿命の関係

カラーテレビの普及率、平均寿命のデータは、それぞれ1966年から1980年までの同じ15年間のデータに揃えてある。そこで、横軸をカラーテレビの普及率、縦軸を平均寿命としてプロットしてみよう。以下を実行せよ。

```py
plt.xlabel("TV")
plt.ylabel("Lifespan")
plt.scatter(tv_data, life_data)
```

テレビの普及率の高い年ほど、平均寿命が長いことがわかるであろう。

#### 8. テレビの普及率と寿命の関係

カラーテレビの普及率と寿命には何かしら強い関係がありそうであった。そこで、両者の相関を調べてみよう。相関とは、お互いに完全に比例している場合に1、完全に反比例している時に-1、完全に無関係である時に0となるような量である。

相関は`numpy`の`corrcoef`で調べることができる。以下を実行せよ。

```py
np.corrcoef(tv_data, life_data)
```

2行2列の行列が表示されたはずだ。対角成分は「自分自身との相関」なので1である。非対角成分が「テレビと寿命」の関係だ。1に近い値が表示されているはずだ。このデータから「テレビが普及している年ほど寿命が長い」ということが客観的に示された。

以上の解析結果をもって、例えば「テレビを見るほど寿命が伸びる」と結論してよいか考察せよ。

## 余談：消えていくアイコンのオリジナルたち

パソコンを使っていると、ファイルを管理するのにフォルダを使ったことがあるだろう。Windowsであれば、右クリックのメニューで「新規作成」から「フォルダ」を作ることができる。また、iPadやiPhoneなどのスマホでも、アイコン長押しからドラッグでまとめてフォルダを作ることができる。もともと「フォルダ」とは実在する文房具である。

TODO: ファイルとフォルダ
TODO: 図書館とカード目録 (inode)
