
# ファイル操作

* ファイルシステムについて
* ファイルの読み込み
* CSVファイルの扱い
* データ解析

## ファイルとは何か

Pythonなどのスクリプト言語を使えるようになると、使えない場合に比べて飛躍的に作業効率が上がる。特に、大量のファイルを解析、変換したいといったケースで、一つ一つエクセルで開いては作業する人に比べて、Pythonその他スクリプト言語とシェルスクリプト等を組み合わせて処理できる人は、生産性に圧倒的な差が出る。そこで、今回はPythonでCSVファイルを開いて、データの解析を行う。しかし、まずその前に「そもそもファイルとは何か」を知っているだろうか？

我々がコンピューターを使う際、何気なくファイルを触っている。スマートフォンで以前撮影した写真を見てみたり、ダウンロードした音楽を聞いたりしている時、意識はしていないかもしれないが、裏ではアプリケーションが写真ファイルや音楽ファイルを開いて読み込み、再生している。また、パソコンで、デスクトップにあるファイルをダブルクリックして開いたり、「あのファイルどこにやったかな」とディレクトリを探し回ったりしたことがあるだろう。スマホでもパソコンでも、何かデータにアクセスする際は、ほとんどの場合においてファイルの読み書きという形をとっている。ファイルの実体は、例えばハードディスクやSDカードに記録されたデータであり、両者は物理的には全く異なるアクセスをしているにも関わらず、保存先がハードディスクであってもSDカードであっても、同じようにアクセスすることができ、我々はその裏で何が起きているのかを意識することはほとんどない。それは、オペレーティングシステムが、「ファイルを管理する」という面倒な作業を代わりにやってくれているからだ。このファイルを管理する仕組みを「ファイルシステム」と呼ぶ。

おそらく、今後の人生でファイルシステムの知識が必要になることはほとんどないであろう。必要になるとしても、せいぜい「SDカードやUSBメモリをフォーマットする時に、ファイルシステムの種類に気を付けないとWindowsとMacで互換性の問題が起きる」といった程度で、ファイルシステムの仕組みや動作について知っていても役に立つことはないと思われる。しかし、役に立つ、立たないは別として、普段使っているパソコンやスマホの裏で、「ファイル」や「フォルダ」がどのような仕組みで管理されているか知っておいても良いであろう。それが教養というものである。

## ファイルシステムについて

我々が普段使うスマホのデータは主にSDカードに保存されている。また、パソコンのデータはハードディスク、もしくはSSDに保存されている。SDカード、ハードディスク、SSDなどを総称してストレージ(storage)と呼ぶ。ストレージは、外部補助記憶装置とも呼ばれ、計算機のデータを長期間保存するためのデバイスである。

これらストレージは、「ブロック」もしくは「クラスタ」と呼ばれる単位でデータを読み書きする。ブロックのサイズはデバイスによって異なるが、おおむね4KB程度である。ストレージには、ブロック単位で通し番号がつけられており、「12番のブロックからデータを読み込む」「488番と489番のブロックにデータを書き込む」といった形でデータの読み書きを行う。もし、これらのストレージを「生のまま」使うならば、ユーザが「どのブロックに何を書き込んだか」をすべて覚えておかなければならない。これは面倒なので、ブロックに「ラベル」をつけたくなるであろう。例えば「0番のブロックにはtest.txtというラベル」、「1番のブロックにはhoge.cppというラベル」といった具合である。この、ブロックに対するラベルの役割をするのがファイル名である。また、ファイルが増えてくると、それをグループ単位で管理したくなる。これがフォルダである。

データが大きい時には、1つのブロックには収まりきらない。例えばブロックのサイズが4KBの時、10KBのデータを保存するには3つのブロックが必要となる。この時、いちいち空いているブロックを探して「4,5,6番のブロックに保存」などと指定するのは面倒である。しかも、ブロック単位で書いたり消したりしているうちに、「空いている(使って良い)ブロック」が不連続になってくる。この時に大きなデータを書き込むためには、一つのファイルをバラバラのデータに分けて保存しなければならない。さらに、そのデータの一部を修正するためには、そのデータのその場所がどのブロックに保存されているかを調べる必要がある。これをすべてが覚えておくのは大変だし、計算機側に自動で管理して欲しいと思うであろう。

このように、ストレージにブロック単位で保存されているデータに、ファイル名やフォルダといった構造を与え、人間にとって扱いやすくするのがファイルシステムである。ファイルシステムには数多くの種類があるが、Linux系ならext4やxfs、WindowsはNTFS、USBメモリなどにはexFATなどがよく使われている。このうち、いま使っているGoogle Colabでも採用されているext4について簡単に説明しよう。なお、WindowsやMacではファイルをまとめて管理する仕組みを「フォルダ」と呼ぶが、Linuxでは「ディレクトリ」と呼ぶため、以後、ディレクトリと呼ぶことにする。細かいことを言い出すときりがないが、とりあえず「フォルダ」と「ディレクトリ」は同じものだと思っておいてよい。また、簡単のため、以下ではかなり説明を省くことに注意(例えばジャーナルの説明や特別なブロックの説明はしない)。

### inode

すでに述べたように、ストレージは「ブロック」という単位でデータの読み書きをする。一つもしくは複数のブロックにまたがって保存されているデータにつけた別名が「ファイル」である。「どのブロックが、どのファイルに所属するか」を記録しているのがinodeと呼ばれるデータだ。全てのファイルには一意なinode番号が割り振られる。inodeには、inode番号、どのブロックを使っているか、ファイルサイズはどれくらいか、所有者は誰かなどの情報が保存されている。inode番号には上限があり、もし使い切った場合は、たとえストレージ容量に余裕があっても新たにファイルを作ることはできない。

![inodeによるファイル管理](fig/inode.png)

ディレクトリもinode番号を持っており、inodeデータとして管理されている。実はinodeはファイル名を保持しておらず、ファイル名はディレクトリが管理している。ディレクトリは、自身が管理するファイルとinode番号の対応表を持っている。Linux系のファイルシステムでは、ディレクトリは「.(ドット)」と「..(ドットドット)」という二つの特別なディレクトリを持つ。それぞれ「自分自身」と「親ディレクトリ」を指している。

なぜファイルを管理するinodeがファイル名を持たず、ディレクトリがファイル名を管理しているのかについては、いくつか理由がある。まず、一つのinodeに複数のファイル名が対応する場合があり、inode番号だけでは、どのファイル名に対応するかがわからない。つまり「ファイル名」から「inode番号」は一意に決まるが、「inode番号」から「ファイル名」は一意には決まらない。この仕組みをハードリンクと呼ぶが、本講義では詳細は扱わない。

もう一つの理由は、素早い検索のためだ。WindowsでもMacでも、あるフォルダをダブルクリックするとそのフォルダが開き、中にあるファイル一覧を見ることができる。もし、inodeがファイル名を管理しているならば、まずそのフォルダ(ディレクトリ)の直下にあるinode一覧をリストアップし、そのinodeデータそれぞれについてファイル名を読み込みにいかなければならない。つまり、ファイル数の分だけinodeデータにアクセスしなければならず、レスポンスが極めて遅くなる。もしディレクトリがinode番号とファイル名のリストを持っていれば、「現在のディレクトリの直下にあるファイル一覧」はディスクアクセス一発で得ることができる。これは、今よりもはるかにディスクアクセスが遅かった時代の工夫の名残である。

なお、inodeが管理するようなファイル名や所有者情報、ファイルサイズなどは「メタデータ」と呼ばれる。あるディレクトリ以下にあるファイルをすべて再帰的にリストアップする場合や、名前でファイルを検索する場合など、ファイル操作では「ファイルの中身までは見なくても良い」処理が多い。例えばネットサーフしているときに「ネットが重い」と大変不快なのと同様に、フォルダを開いて中身が表示されるまでに時間がかかると大変不快である。普段あまり意識することは少ないが、メタデータの検索速度はパソコンの「使い勝手」に直結する。

そこで、多くのファイルシステムでは、メタデータを管理する場所とファイルの中身を管理する場所を別々に分け、効率的にメタデータを扱えるように工夫がしてある。スパコンなどで使われるLustreなどの並列ファイルシステムは、メタデータとファイルの中身は別のサーバで管理されており、高速なメタデータアクセスを実現している。

### ファイルのオープン・クローズ

Pythonに限らず、プログラムからファイルを読み書きするには、まずファイルを開く必要がある。「ファイルを開く」とは、「ファイルシステムにファイルの場所を問い合わせて、プロセスからファイルを扱えるように回線をつなぐ」ことである。プログラムは、「プロセス」という形でOSに管理されている。プロセスからOSにファイルへの接続要求があると、OSはファイルシステムにその場所を問い合わせて、プロセスとファイルシステムの間に特別な回線を作って接続する。この回線は「ファイルディスクリプタ」という、内線番号のようなもので管理される。0番から2番までのファイルディスクリプタは特別な回線となっており、それぞれ標準出力、標準出力、標準エラー出力として予約されている。一度ファイルが開かれたら、プロセスはこのファイルディスクリプタを使ってデータを読み書きする。プロセスは同時に複数の回線を保持できるが、回線の数には上限があるため、不要になったら解放する必要がある。そこで、ファイルへの接続が不要になったら、「ファイルを閉じる」必要がある。ファイルを閉じると、回線を破棄し、内線番号(ファイルディスクリプタ)もOSに返却する。その後でファイルを開くと、ファイルディスクリプタは再利用される。

![ファイルオープンの仕組み](fig/fd.png)

なお、この図では省略されているが、実際にはファイル名(test.txt)から、対応するinodeを調べ、そのinodeが指しているブロックを調べ、そのブロックの場所を覚えて、以後の読み書きはそのブロックに対して行う、ということが行われている。

# ファイル操作：課題

## 課題1：ファイルシステムを見てみる

### 課題1-1：ファイルシステムの確認

新しいノートブックを開き、実際にGoogle Colabのファイルシステムがどうなっているかを確認しよう。

#### 1. ファイルシステムの確認

最初のセルに、以下を入力、実行せよ。

```py
! df -T
```

すると以下のような出力が出てくるはずだ。

```txt
Filesystem     Type    1K-blocks     Used Available Use% Mounted on
overlay        overlay  51343840 26636520  22069496  55% /
tmpfs          tmpfs     6667636        0   6667636   0% /dev
...
```

ファイルシステム、`/dev/sda1`の「Type」はどうなっているだろうか？

#### 2. ファイルとinodeの確認

次に、実際にファイルを作成して、そのinode番号を調べてみよう。
2番目のセルに以下を入力、実行せよ。

```py
! touch test.txt
! stat test.txt
```

「test.txt」のファイル情報が表示されたはずだ。「Size」や「Inode」の番号がどうなっているか確認せよ。

#### 3. ディレクトリとinode一覧

現在のディレクトリにあるファイルの一覧とinode番号を確認してみよう。
カレントディレクトリにあるファイル一覧を表示するコマンド`ls`に、inode番号も表示するオプション`-i1`(iの後ろはエルではなくて数字の1であることに注意)を指定してみよう。ついでに`-F`もつけて、ディレクトリであることを明示させる。

```py
! ls -F -i1
```

先ほど作成した`test.txt`と、もともと存在するディレクトリ`sample_data/`が表示され、それぞれの左にinode番号が表示されたはずである。`test.txt`のinode番号が先ほど`stat`で調べたinode番号と一致することを確認せよ。

## 課題2：CSVファイルを読み込む

## 余談：消えていくアイコンのオリジナルたち

パソコンを使っていると、ファイルを管理するのにフォルダを使ったことがあるだろう。Windowsであれば、右クリックのメニューで「新規作成」から「フォルダ」を作ることができる。また、iPadやiPhoneなどのスマホでも、アイコン長押しからドラッグでまとめてフォルダを作ることができる。もともと「フォルダ」とは実在する文房具である。

TODO: ファイルとフォルダ
TODO: 図書館とカード目録 (inode)
