<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>

<style>
  .markdown-body {
    box-sizing: border-box;
    min-width: 200px;
    max-width: 980px;
    margin: 0 auto;
    padding: 45px;
  }
  img {width: 100%}

  @media (max-width: 767px) {
    .markdown-body {
      padding: 15px;
    }
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article class="markdown-body">
<h1 id="数値シミュレーション"><a href="https://kaityo256.github.io/python_zero/simulation/">数値シミュレーション</a></h1>
<ul>
<li>弾道計算1: 抵抗なし</li>
<li>弾道計算2: 抵抗あり</li>
<li>反応拡散方程式(Gray-Scott Model)</li>
</ul>
<h2 id="はじめに">はじめに</h2>
<p>互いに重力で引き合う二つの星の軌道の形が楕円となることは知っているであろう。ではなぜ楕円となるか、答えられるだろうか？様々な答えはあろうが、一つの答えは「距離の逆二乗に比例する力で互いに引き合う二つの物質の運動方程式を解くと、その軌道が楕円となるから」である。さて、運動方程式とはなんだったか覚えているだろうか。最も簡単な運動方程式は<span class="math inline">\(F=ma\)</span>である。これは、物質にかかる加速度と力が比例し、その比例係数が物質の質量であることを主張する。さて、加速度とは何か？それは速度の時間変化である。したがって、先ほどの運動方程式は、より正確に書くと</p>
<p><span class="math display">\[
m \frac{d v}{dt} = F
\]</span></p>
<p>となる。さらに速度とは、単位時間当たりの位置の変化分であった。したがって、それもちゃんと書くと、</p>
<p><span class="math display">\[
\begin{aligned}
\frac{d v}{dt} &amp;= \frac{F}{m} \\
\frac{d r}{dt} &amp;= v
\end{aligned}
\]</span></p>
<p>これが運動方程式である。すなわち、運動方程式とは時間に関する連立常微分方程式である。上記の式は一次元で書いたが、これを三次元の式にして、さらに二つの物質の間に距離の二乗に反比例する力を仮定すると、互いに重力で引き合う二つの星の運動を表す方程式となる。これを解くと、軌道が楕円になることや、面積速度一定則、調和の法則など、いわゆるケプラーの三法則が導かれる。</p>
<p>物理学とは、この宇宙を記述する学問である。そして(なぜかはわからないが)この宇宙は微分方程式で記述されている(らしい)。したがって、物理学とは、微分方程式を解く学問である。幸か不幸か、ほとんどの微分方程式は解析的に解くことができない。しかし、方程式さえわかれば、それを数値的に解くことは可能である。何かの現象に着目し、それを記述する方程式を支配方程式(Governing Equation)と呼ぶ。支配方程式を数値的に解いて、その振る舞いを調べることを数値シミュレーションと呼ぶ。というわけで、今回は数値シミュレーションをやってみよう。</p>
<h2 id="弾道計算1-抵抗無し">弾道計算1: 抵抗無し</h2>
<p>ものを斜め上に投げると、どの角度で投げると最も遠くに飛ぶだろうか。ただし空気抵抗は無視するものとする。答えが投げる強さ(初速)に依らず45度であることは知っているであろう。では逆に、初速と的までの距離が決まっているときに、何度で投げれば的に当てることができるだろうか？例えば初速100m/sで、500m先にある的に当てたいときの角度は？空気抵抗を無視すれば、二次方程式を解くだけだが、すぐに暗算するのは難しいであろう。この「重力下で物に初速を与えて飛ばす」という設定は、物理としてはかなり簡単な部類に入るが、戦争においては極めて重要な問題設定であった。例えば敵までの距離がわかっているときに、迫撃砲の角度を何度にすればよいかを「すぐに」決めなくてはならない。当然だが戦闘中にいちいち方程式を解く暇はなく、実際には空気的もあるために距離と角度の関係は難しい。そこで、あらかじめ弾の種類と距離の応じて「射表」と呼ばれる距離と角度の関係表を作っておいた。実際に射出して着弾距離を調べることももちろん行われたが、数値計算も行われた。最初期の電子計算機であるENIACは、もともと砲撃の射表の作成のために作られたものだ。ENIACは微分方程式を解くことができ、これが本格的な数値シミュレーションの始まりである。ENIACはその後「マンハッタン計画」にも用いられたことからもわかるように、計算機は軍事利用と深い関係にあり、スーパーコンピュータは半ば「兵器」として扱われた。強力な計算機を保有することが軍事的に優位に立つのに必要であり、実は現在もその名残が様々なところにみられるのだが、それはさておく。</p>
<p>さて、いま皆さんの目の前にあるのは、ちょっと前のスーパーコンピュータなみの計算能力を持つ計算機である。それを使って、簡単なシミュレーションをしてみよう。まずは空気抵抗がない場合である。</p>
<p>以下のプログラムを三つのセルに分けて入力し、実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> math <span class="im">import</span> pi, cos, sin</code></pre></div>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> run(theta):
  x, y <span class="op">=</span> <span class="fl">0.0</span>, <span class="fl">0.0</span>
  vx, vy <span class="op">=</span> cos(theta), sin(theta)
  ax, ay <span class="op">=</span> [], []
  g <span class="op">=</span> <span class="fl">1.0</span>
  dt <span class="op">=</span> <span class="fl">0.01</span>
  <span class="cf">while</span> y <span class="op">&gt;=</span> <span class="fl">0.0</span>:
    x <span class="op">+=</span> vx <span class="op">*</span> dt
    y <span class="op">+=</span> vy <span class="op">*</span> dt
    vy <span class="op">-=</span> g <span class="op">*</span> dt
    ax.append(x)
    ay.append(y)
  nx <span class="op">=</span> np.array(ax)
  ny <span class="op">=</span> np.array(ay)
  <span class="cf">return</span> nx, ny</code></pre></div>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">nx, ny <span class="op">=</span> run(pi<span class="op">*</span><span class="fl">0.25</span>)
plt.plot(nx,ny)
plt.legend()
plt.show()</code></pre></div>
<h3 id="課題1">課題1</h3>
<p>TODO: pi/4が最も飛ぶことを確認させる</p>
<h2 id="弾道計算2-抵抗あり">弾道計算2: 抵抗あり</h2>
<h2 id="反応拡散方程式グレイスコット模型">反応拡散方程式(グレイ・スコット模型)</h2>
<p>先ほどまでは弾道計算を行った。飛翔体の計算は奥が深いのだが、結果がやや地味なのは否めない。せっかくシミュレーションをするので、もう少し結果が派手な計算をしてみよう。そのような例として、反応拡散系(Diffusion-Reaction System)を取り上げる。</p>
<p>等モルの塩酸と水酸化ナトリウムを混ぜると、食塩水ができることは知っているであろう。この反応は一方的であり、混ざって食塩ができておしまいである。しかし、ある種類の化合物を混ぜて反応させると、ある物質ができたり消えたりを繰り返すことがある。最も有名な例はBZ反応(ベロウゾフ・ジャボチンスキー反応, Belousov-Zhabotinsky Reaction)であろう。これは、ある溶液を混ぜると、その後しばらく溶液の色が周期的に変動する現象である。非常に雑に説明すると、反応を記述する方程式が時間の二階微分方程式になり、振動解が出てくるのがこの現象の本質である。</p>
<p>さて、BZ反応は時間的に変動する現象であるが、これが「拡散(Diffusion)」と結びつくと、時間的な変動が空間的に伝播していく。これにより複雑な模様ができあがる。化学反応(Reaction)と拡散(Diffusion)が組み合わさった現象であるから反応拡散系(Diffusion-Reaction System)と呼ばれる。反応拡散系は様々な例が知られているが、筆者の趣味でグレイ・スコットモデル(Gray-Scott model)を取り上げる。</p>
<p>グレイ・スコットモデルは、以下のような連立偏微分方程式で記述される。</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial u}{\partial t} &amp;= D_u \nabla^2 u - uv^2 + F(1-u) \\
\frac{\partial v}{\partial t} &amp;= D_v \nabla^2 v + uv^2 - (F+k)v
\end{aligned}
\]</span></p>
<p>右辺の第一項が拡散項、その後ろにあるのが反応を記述する力学系である。三次元を考えることもできるが、ここでは二次元空間を考える。</p>
<h3 id="差分化">差分化</h3>
<p>さて、この式を計算機で扱えるように離散化しよう。離散化とは、本来連続である時間や空間を「小さな単位」に分解して近似することだ。例えばテレビは、画像をピクセルに分解して表現しており(空間の離散化)、また1秒間に30フレームを表示している(時間の離散化)。このように、時間も空間も十分小さい単位に区切って表現すれば、もとの連続空間での微分方程式の解の性質を精度よく表現できると考えられる。</p>
<p>例えば、ある関数<span class="math inline">\(f(t)\)</span>の時間微分を離散化で近似したいとする。時間の離散単位(時間ステップ)を<span class="math inline">\(h\)</span>とし、テイラー展開で一次までとると、</p>
<p><span class="math display">\[
\begin{aligned}
f(t + h) &amp;= f(t) + f&#39;(t)h + O(h^2) \\
&amp;\sim f(t) + f&#39;(t)h
\end{aligned}
\]</span></p>
<p>となる。つまり、時刻<span class="math inline">\(t\)</span>における<span class="math inline">\(f(t)\)</span>の値と、その微係数<span class="math inline">\(f&#39;(t)\)</span>がわかっていれば、時刻<span class="math inline">\(t+h\)</span>における値<span class="math inline">\(f(t+h)\)</span>は、<span class="math inline">\(f(t) + f&#39;(t)h\)</span>で近似できる、という意味である。これは時間微分に関してテイラー展開の一次で近似しているので、そのまま一次近似と呼ばれる。また、別名をオイラー法と呼ぶ。このように、時間や空間を離散化し、微分を離散単位で近似することを <strong>差分化</strong> と呼ぶ。</p>
<p>次に空間を離散化しよう。今は二次元空間を考えているが、まずは一次元の世界<span class="math inline">\(f(x)\)</span>を考える。微分方程式に二階微分が含まれているので、二階微分を近似したい。そのために、<span class="math inline">\(f(x+h)\)</span>と<span class="math inline">\(f(x-h)\)</span>をそれぞれ二次までテイラー展開してみよう。</p>
<p><span class="math display">\[
\begin{aligned}
f(x + h) &amp;= f(x) + f&#39;(x)h + \frac{h^2}{2} f&#39;&#39;(x) + O(h^3) \\
f(x - h) &amp;= f(x) - f&#39;(x)h + \frac{h^2}{2} f&#39;&#39;(x) + O(h^3) 
\end{aligned}
\]</span></p>
<p>両辺足すと<span class="math inline">\(f&#39;(x)\)</span>の項が消えるので、整理して</p>
<p><span class="math display">\[
f&#39;&#39;(x) = \frac{f(x+h) - 2 f(x) + f(x-h)}{2h}
\]</span></p>
<p>を得る。これを <strong>中央差分</strong> と呼ぶ。</p>
<p>全く同様にして、二変数関数の二階微分(ラプラシアン)は、以下のように表現できる。</p>
<p>先ほどの微分方程式は、時間に関して一階微分、空間に関して二階微分であったので、これで必要な式がそろった。<span class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>を二次元配列として保持し、適当な初期条件を与える。ある時刻において<span class="math inline">\((ix,iy)\)</span>において、物理量<span class="math inline">\(u\)</span>の値が<code>u[ix][iy]</code>で与えられているとしよう。この点におけるラプラシアン<span class="math inline">\(\nabla^2 u\)</span>の値は</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> laplacian(ix, iy, u):
    ts <span class="op">=</span> <span class="fl">0.0</span>
    ts <span class="op">+=</span> u[ix<span class="op">-</span><span class="dv">1</span>, iy]
    ts <span class="op">+=</span> u[ix<span class="op">+</span><span class="dv">1</span>, iy]
    ts <span class="op">+=</span> u[ix, iy<span class="op">-</span><span class="dv">1</span>]
    ts <span class="op">+=</span> u[ix, iy<span class="op">+</span><span class="dv">1</span>]
    ts <span class="op">-=</span> <span class="fl">4.0</span><span class="op">*</span>u[ix, iy]
    <span class="cf">return</span> ts</code></pre></div>
<p>で与えられる。他の項は「現時刻のその場所の値」で計算可能なので、これで次のステップの値が求まる。</p>
<div class="figure">
<img src="fig/sabun.png" alt="差分計算の流れ" />
<p class="caption">差分計算の流れ</p>
</div>
<h2 id="余談パーソナルスーパーコンピュータ">余談：パーソナルスーパーコンピュータ</h2>
<p>パソコンとは「パーソナルコンピュータ」の略、つまり「個人向け計算機」という意味だ。もともと計算機は貴重品かつ大型であり、組織に一つしかないものだった。それが徐々に小型化し、オフィスに一つ(オフコン)になり、さらに個人で独占して利用できるものになった。パソコンが普及するにつれて、もともと「組織に一つ」しかないような巨大な計算機は「スーパーコンピュータ(スパコン)」と呼ばれ、パソコンと区別されるようになった。スパコンは、安くて一億、高ければ数十、数百億円といったその価格もさることながら、その維持も大変である。計算するのには莫大な電気が必要で、かつ使った電気はすべて熱となるからそれを冷却するシステムも必要である。したがって、本来「パソコン」と「スパコン」は相容れない概念のはずだが、スパコンを個人で所有することでその二つを悪魔合体させ、「パーソナルスーパーコンピュータ」という狂った概念を生み出した人がいる。桑原邦郎氏である。彼は流体力学を専門とする研究者で、親から受け継いだ莫大な財産をすべてスパコンに突っ込んだ。自宅に計算流体力学研究所という研究所を作り、そこにスパコンを購入して運用した。最盛期は七台のスパコンがフル稼働し、電気代だけで月に2000万円かかったという。1980年代後半から1990年代にかけて、計算流体力学を専門とする人はほとんど彼のパーソナルスパコンにお世話になったと思われる。自動車メーカも技術者を派遣していたそうだ。また、米国の諜報機関が「軍事目的に使っているのではないか」と疑ったとのエピソードもある。彼は親から受け継いだ莫大な遺産をすべてスパコンに突っ込み、それを惜しげもなくいろんな人に使わせた。</p>
<p>それから紆余曲折あって、計算流体力学研究所はスパコンを手放し、技術コンサルやパソコンの組み立て、販売をする会社となった。私が大学院に進学した際に与えられたパソコンは、この計算流体力学研究所で購入したAlpha21164のマシンであった。指導教員の「せっかくだから組み立てさせてもらったら？」の言葉に甘え、目黒に行ってアルバイトのお兄さんと一緒に自分の研究に使うマシンを組み立てた。そこに社長である桑原氏が様子を見にやってきた。僕が物工の学生と知ると、興味をもっていろいろ聞いてきた。僕はまさか目の前の社長さんが元物工の助手だったなんて知らなかったので「物工のご出身なんですか？どこの研究室ですか？」と的外れな質問をした。彼はただ笑って何も答えなかったのを思い出す。その時は青二才で何もわからなかった私だが、スパコンを使って研究をするようになった今なら、彼からいろいろ興味深い話が聞けたのではないかと残念に思う。桑原氏は2008年、その豪快な生涯を閉じた。「親の遺産をもっとも有効に学術に活かした」と評されている。</p>
</article>
</body>
</html>
