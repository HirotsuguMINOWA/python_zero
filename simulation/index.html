<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>

<style>
    .btn-square {
      display: inline-block;
      padding: 0.5em 0.5em;
      text-decoration: none;
      background: #668ad8;
      color: #FFF;
      border-bottom: solid 4px #626295;
      border-radius: 5px;
    }

    .btn-square:active {
      -webkit-transform: translateY(4px);
      transform: translateY(4px);
      border-bottom: none;
    }
  .markdown-body {
    box-sizing: border-box;
    min-width: 200px;
    max-width: 980px;
    margin: 0 auto;
    padding: 45px;
  }
  p.caption{
    display:none;
  }
  img {width: 100%}

  @media (max-width: 767px) {
    .markdown-body {
      padding: 15px;
    }
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>
<body>
<article class="markdown-body">
<h1 id="数値シミュレーション"><a href="https://kaityo256.github.io/python_zero/simulation/">数値シミュレーション</a></h1>
<p><a href="../index.html">[Up]</a> <a href="https://github.com/kaityo256/python_zero">[Repository]</a></p>
<ul>
<li>拡散方程式</li>
<li>反応拡散方程式(Gray-Scott Model)</li>
<li>余談：パーソナルスーパーコンピュータ</li>
</ul>
<h2 id="数値シミュレーションとは">数値シミュレーションとは</h2>
<p>物理学とは、我々が存在するこの宇宙を記述する学問である。そして(なぜかはわからないが)この宇宙は微分方程式で記述されている(らしい)。したがって、物理学とは、微分方程式を解く学問である。幸か不幸か、ほとんどの微分方程式は解析的に解くことができない。しかし、方程式さえわかれば、それを数値的に解くことは可能である。何かの現象に着目し、それを記述する方程式を <strong>支配方程式(Governing Equation)</strong> と呼ぶ。この支配方程式を、数値的に解くことでその振る舞いを調べることを <strong>数値シミュレーション(Numerical Simulation)</strong> と呼ぶ。</p>
<p>さて、この世界の空間や時間は(たぶん)連続的であるのに対し、コンピュータは原則として離散的な値しか扱うことができない。数値シミュレーションとはこの世界の出来事をコンピュータの中に再現することであるから、計算するにあたって連続的な値を離散的な値に変換する必要がある。例えば、パソコンやスマホで動画を見ることがあるだろう。動画は、我々が目にする世界のように、空間的にも時間的にも連続的に見えるが、実際には時間方向は静止画像を高速にコマ送りすることで連続的に見せており、静止画像も拡大するとピクセル単位で離散化されている。</p>
<div class="figure">
<img src="fig/discretization.png" alt="時間と空間の離散化" />
<p class="caption">時間と空間の離散化</p>
</div>
<p>このように、連続的な値をコンピュータで扱うために離散的な値にすることを <strong>離散化(discretization)</strong> と呼ぶ。以下では、時間や空間を離散化することで微分方程式を計算機が扱いやすい形にして、その振る舞いを数値シミュレーションで解析してみよう。</p>
<h2 id="ニュートンの運動方程式">ニュートンの運動方程式</h2>
<p>互いに重力で引き合う二つの星の軌道の形が楕円となることは知っているであろう。ではなぜ楕円となるか、答えられるだろうか？様々な答えはあろうが、一つの答えは「距離の逆二乗に比例する力で互いに引き合う二つの物質の運動方程式を解くと、その軌道が楕円となるから」である。さて、運動方程式とはなんだったか覚えているだろうか。最も簡単な運動方程式は<span class="math inline">\(F=ma\)</span>である。これは、物質にかかる加速度と力が比例し、その比例係数が物質の質量であることを主張する。さて、加速度とは何か？それは速度の時間変化である。したがって、先ほどの運動方程式は、より正確に書くと</p>
<p><span class="math display">\[
m \frac{d v}{dt} = F
\]</span></p>
<p>となる。さらに速度とは、単位時間当たりの位置の変化分であった。したがって、それもちゃんと書くと、</p>
<p><span class="math display">\[
\begin{aligned}
\frac{d v}{dt} &amp;= \frac{F}{m} \\
\frac{d r}{dt} &amp;= v
\end{aligned}
\]</span></p>
<p>これが運動方程式である。すなわち、運動方程式とは時間に関する連立常微分方程式である。上記の式は一次元で書いたが、これを三次元の式にして、さらに二つの物質の間に距離の二乗に反比例する力を仮定すると、宇宙空間内で互いに重力で引き合う二つの星の運動を表す方程式となる。これを解くと、軌道が楕円になることや、面積速度一定則、調和の法則など、いわゆるケプラーの三法則が導かれる。 自然科学において <strong>法則(law)</strong> とは、実験や観測などで再現可能な自然の振る舞いである。物理学とは、より基本的な原理から、観測事実である「法則」を導き、説明しようとする営みである。</p>
<h3 id="空気抵抗がない場合の弾道計算">空気抵抗がない場合の弾道計算</h3>
<p>ものを斜め上に投げた時、最も遠くに飛ばすにはどんな角度で投げればよいだろうか。ただし空気抵抗は無視するものとする。答えが投げる強さ(初速)に依らず45度であることは知っているであろう。では逆に、初速と的までの距離が決まっているときに、何度で投げれば的に当てることができるだろうか？例えば初速100m/sで、500m先にある的に当てたいときの角度は？空気抵抗を無視すれば、二次方程式を解くだけだが、すぐに暗算するのは難しいであろう。この「重力下で物に初速を与えて飛ばして目的の場所に落とす」という設定は、戦争においては極めて重要な問題設定であった。例えば敵までの距離がわかっているときに、迫撃砲の角度を何度にすればよいかを「すぐに」決めなくてはならない。当然だが戦闘中にいちいち方程式を解く暇はなく、実際には空気抵抗もあるために距離と角度の関係は難しい。そこで、あらかじめ弾の種類と距離の応じて「射表」と呼ばれる距離と角度の関係表を作っていた。実際に射出して着弾距離を調べることももちろん行われたが、数値計算も行われた。最初期の電子計算機であるENIACは、もともと砲撃の射表の作成のために作られたものだ。ENIACは微分方程式を解くことができ、これが本格的な数値シミュレーションの始まりである。ENIACはその後「マンハッタン計画」にも用いられたことからもわかるように、計算機は軍事利用と深い関係にあり、スーパーコンピュータは半ば「兵器」として扱われた。強力な計算機を保有することは軍事的に優位に立つのに必要であり、実は現在もその名残が様々なところにみられるのだが、それはさておく。</p>
<p>さて、いま皆さんの目の前にあるのは、ちょっと前のスーパーコンピュータなみの計算能力を持つ計算機である。それを使って、簡単なシミュレーションをしてみよう。まずは空気抵抗がない場合である。二次元の場合を考えよう。速度ベクトルを<span class="math inline">\(\vec{v} = (v_x, v_y)\)</span>、位置ベクトルを<span class="math inline">\(\vec{r} = (r_x, r_y)\)</span>とし、運動方程式をそれぞれの要素について書き下すと以下のようになる。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{v_x} &amp;= 0 \\
\dot{v_y} &amp;= - g \\
\dot{r_x} &amp;= v_x \\
\dot{r_y} &amp;= v_y
\end{aligned}
\]</span></p>
<p>さて、この式は厳密に解けるのだが、その厳密解を知らないものとし、シミュレーションで近似的に解を求めることにする。求めたいものは重力下で角度<span class="math inline">\(\theta\)</span>で物体を投げた時の物体の軌道である。まず、数値計算で扱いやすいように、時間を離散化しよう。</p>
<p>今、ある量<span class="math inline">\(f(t)\)</span>の時間微分<span class="math inline">\(f&#39;(t)\)</span>が与えられているとしよう。時間に関する離散化とは、ある小さな時間刻みを<span class="math inline">\(h\)</span>に対して、<span class="math inline">\(f(t)\)</span>の値からなんとかして<span class="math inline">\(f(t+h)\)</span>の値を推定することである。時間微分<span class="math inline">\(f&#39;(t)\)</span>がわかっているので、厳密な表式は積分で与えられる。</p>
<p><span class="math display">\[
f(t+h) = f(t) + \int_t^{t+h} f&#39;(t) dt
\]</span></p>
<p>この式の意味は時刻<span class="math inline">\(t\)</span>において<span class="math inline">\(f(t)\)</span>の値である時、それに<span class="math inline">\(t\)</span>から<span class="math inline">\(t+h\)</span>までの時間変化<span class="math inline">\(f&#39;(t)\)</span>をすべて積算したものを加えると<span class="math inline">\(f(t+h)\)</span>の値になります、ということであり、なんら難しいことは言っていない。</p>
<p>さて、一般にはこの積分を求積することはできないので、なんらかの近似をする。最も単純な近似は、時間刻み<span class="math inline">\(h\)</span>が小さいので、その間は<span class="math inline">\(f&#39;(t)\)</span>が時間変化しないものとみなすことだろう。すると、<span class="math inline">\(f&#39;(t)\)</span>を積分の外に出すことができるので、</p>
<p><span class="math display">\[
f(t+h) \sim f(t) + h f&#39;(t)
\]</span></p>
<p>と近似することができる。<span class="math inline">\(f(t+h)\)</span>を<span class="math inline">\(t\)</span>の周りでテイラー展開して、一次までとると、</p>
<p><span class="math display">\[
\begin{aligned}
f(t + h) &amp;= f(t) + f&#39;(t)h + O(h^2) \\
\end{aligned}
\]</span></p>
<p>となることから、先程の近似は<span class="math inline">\(h\)</span>の一次まで正しい。これを一次近似と呼ぶ。この式は、右辺、すなわち時刻<span class="math inline">\(t\)</span>における<span class="math inline">\(f(t)\)</span>の値と、その微係数<span class="math inline">\(f&#39;(t)\)</span>がわかっていれば、左辺、すなわち時刻<span class="math inline">\(t+h\)</span>における値<span class="math inline">\(f(t+h)\)</span>は、<span class="math inline">\(f(t) + f&#39;(t)h\)</span>で近似できる、ということを主張する。このように、微分を離散単位で近似することを差分化と呼び、差分化により微分方程式を扱う手法を <strong>差分法(Finite difference method)</strong> と呼ぶ。特に、一次近似の差分法を <strong>オイラー法 (Euler's method)</strong> と呼ぶ。</p>
<div class="figure">
<img src="fig/nextstep.png" alt="時間の差分化" />
<p class="caption">時間の差分化</p>
</div>
<p>先の運動方程式に一次の差分化を適用すると、</p>
<p><span class="math display">\[
\begin{aligned}
v_x(t+h) &amp;= v_x(t) \\
v_y(t+h) &amp;= v_y(t) - g h\\
r_x(t+h) &amp;= r_x(t) + v_x(t) h \\
r_y(t+h) &amp;= r_y(t) + v_y(t) h\\
\end{aligned}
\]</span></p>
<p>となる。この計算を一度行うことで、時刻<span class="math inline">\(t\)</span>の物理量から時刻<span class="math inline">\(t+h\)</span>の物理量が得られる。あとはこれを繰り返せば(時間刻み<span class="math inline">\(h\)</span>の精度で)任意の時刻の位置と速度がわかることになる。</p>
<p>厳密解も求めておこう。</p>
<p>まず、運動方程式から速度に関する部分を抜き出すと以下のようになる。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{v_x} &amp;= 0 \\
\dot{v_y} &amp;= - g
\end{aligned}
\]</span></p>
<p>これは簡単に求積できる。初期条件として、仰角<span class="math inline">\(\theta\)</span>、速度<span class="math inline">\(1\)</span>で投げたとすると、<span class="math inline">\(v_x(0) = \cos \theta, v_y(0) = \sin \theta\)</span>であるから、</p>
<p><span class="math display">\[
\begin{aligned}
v_x(t) &amp;= \cos \theta \\
v_y(t) &amp;= -gt + \sin \theta
\end{aligned}
\]</span></p>
<p>となる。これをさらに時間積分したものが座標であるから、初期位置が <span class="math inline">\(\vec{r}(0) = (0,0)\)</span> であったとすると、</p>
<p><span class="math display">\[
\begin{aligned}
r_x(t) &amp;= t \cos \theta \\
v_y &amp;= -\frac{g t^2}{2} + t \sin \theta
\end{aligned}
\]</span></p>
<p>これが求めたい軌道であった。</p>
<h3 id="空気抵抗がある場合の弾道計算">空気抵抗がある場合の弾道計算</h3>
<p>先程は空気抵抗が無い場合を考えた。次は空気抵抗がある場合を考えよう。一口に空気抵抗と言っても様々な要因があるのだが、ここは単純に「速度に比例して向きと反対向きにひっぱられる力」がかかっていると考えよう。このような力は「ストークス抵抗」と呼ばれ、流体の粘性が極めて高いか、物体の運動が非常に遅い時にしか成り立たないのだが、ここでは深入りしない。</p>
<p>速度<span class="math inline">\(v\)</span>で運動する物体に対して、その速度とは逆向きに<span class="math inline">\(\gamma v\)</span>の力がかかるとしよう。<span class="math inline">\(\gamma\)</span>は比例係数であり、ここでは速度に依存しない定数とする。物体の速度ベクトルが地面となす角度が<span class="math inline">\(\phi\)</span>である時、物体にかかる力を<span class="math inline">\(x\)</span>軸、<span class="math inline">\(y\)</span>軸に分解するとこんな感じになる。</p>
<div class="figure">
<img src="fig/forces.png" alt="物体にかかる力" />
<p class="caption">物体にかかる力</p>
</div>
<p>この図をもとに、速度に関係する運動方程式を書き下すとこうなる。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{v_x} &amp;= - \gamma v \cos \phi \\
\dot{v_y} &amp;= - \gamma v \sin \phi - g \\
\end{aligned}
\]</span></p>
<p>さて、三角関数の定義から</p>
<p><span class="math display">\[
\begin{aligned}
\cos \phi &amp;= \frac{v_x}{v}\\
\sin \phi &amp;= \frac{v_y}{v}\\
\end{aligned}
\]</span></p>
<p>である。これを代入すると、最終的に以下の運動方程式を得る。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{r_x} &amp;= v_x \\
\dot{r_y} &amp;= v_y \\
\dot{v_x} &amp;= -  \gamma v_x \\
\dot{v_y} &amp;= -  \gamma v_y - g
\end{aligned}
\]</span></p>
<p>課題では、この式を実装してみよう。</p>
<p>なお、空気抵抗がある場合も厳密解を得ることができる。</p>
<p>まず、速度に関する運動方程式は以下で与えられていた。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{v_x} &amp;= -  \gamma v_x \\
\dot{v_y} &amp;= -  \gamma v_y - g
\end{aligned}
\]</span></p>
<p>これはそのまま求積することができる。簡単のため、初速を仰角<span class="math inline">\(\theta\)</span>、速度<span class="math inline">\(1\)</span>だったとすると、<span class="math inline">\(v_x(0) = \cos \theta, v_y(0) = \sin \theta\)</span>であることから、解は以下のように求まる。</p>
<p><span class="math display">\[
\begin{aligned}
v_x(t) &amp;= \mathrm{e}^{-\gamma t} \cos{\theta} \\
v_y(t) &amp;= \mathrm{e}^{-\gamma t} \sin{\theta} - \frac{g}{\gamma}(1 - \mathrm{e}^{-\gamma t} )
\end{aligned}
\]</span></p>
<p>このような式を得たら、必ず<span class="math inline">\(t=0\)</span>で初期条件と一致するか、<span class="math inline">\(t\rightarrow \infty\)</span>の場合にどうなるかを確認すること。特に、十分時間が経過した後は<span class="math inline">\(v_x \rightarrow 0, v_y \rightarrow -g/\gamma\)</span>という一定値に収束することがわかる。重力下で抵抗がある場合、最終的に速度が一定に落ち着くが、その落ち着いた速度を <strong>終端速度 (terminal verlocity)</strong> と呼ぶ。</p>
<p>さて、速度が求まったので、これを積分すれば任意の時刻による位置も求めることができる。初期位置が <span class="math inline">\(\vec{r}(0) = (0,0)\)</span> であったとすると、</p>
<p><span class="math display">\[
\begin{aligned}
r_x(t) &amp;=  \frac{(1 - \mathrm{e}^{-\gamma t})\cos{\theta} }{\gamma} \\
r_y(t) &amp;= \frac{(1 - \mathrm{e}^{-\gamma t})\sin{\theta} }{\gamma} + \frac{g (1 -  \mathrm{e}^{-\gamma t} - \gamma t)}{\gamma^2}
\end{aligned}
\]</span></p>
<p>これが空気抵抗がある場合の位置の厳密な軌道である。</p>
<h2 id="反応拡散方程式グレイスコット模型">反応拡散方程式(グレイ・スコット模型)</h2>
<p>先程はニュートンの運動方程式を数値的に解くことで弾道計算を行った。この時、時間のみ離散化し、空間は連続のままだった。次は時間と同時に空間も離散化してみよう。そんな系の例として反応拡散系(Diffusion-Reaction System)を取り上げる。</p>
<p>等モルの塩酸と水酸化ナトリウムを混ぜると、食塩水ができることは知っているであろう。この反応は一方通行であり、混ざって食塩ができておしまいである。しかし、ある種類の化合物を混ぜて反応させると、ある物質ができたり消えたりを繰り返すことがある。最も有名な例はBZ反応(ベロウゾフ・ジャボチンスキー反応, Belousov-Zhabotinsky Reaction)であろう。これは、ある溶液を混ぜると、その後しばらく溶液の色が周期的に変動する現象である。非常に雑に説明すると、反応を記述する方程式が時間の二階微分方程式になり、振動解が出てくるのがこの現象の本質である。</p>
<div class="figure">
<img src="fig/bz.png" alt="BZ反応" />
<p class="caption">BZ反応</p>
</div>
<p>さて、BZ反応は時間的に変動する現象であるが、これが「拡散(Diffusion)」と結びつくと、時間的な変動が空間的に伝播していく。これにより複雑な模様ができあがる。化学反応(Reaction)と拡散(Diffusion)が組み合わさった現象であるから反応拡散系(Diffusion-Reaction System)と呼ばれる。反応拡散系は様々な例が知られているが、そのうちの一つ、グレイ・スコットモデル(Gray-Scott model)を取り上げる。</p>
<p>グレイ・スコットモデルは、以下のような連立偏微分方程式で記述される。</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial u}{\partial t} &amp;= D_u \Delta u - uv^2 + F(1-u) \\
\frac{\partial v}{\partial t} &amp;= D_v \Delta v + uv^2 - (F+k)v
\end{aligned}
\]</span></p>
<p>右辺の第一項が拡散項、その後ろにあるのが反応を記述する力学系である。三次元を考えることもできるが、ここでは二次元空間を考える。</p>
<div class="figure">
<img src="fig/gs.png" alt="Gray-Scott模型" />
<p class="caption">Gray-Scott模型</p>
</div>
<p>まず、空間を差分化して扱うことにしよう。本来連続的な空間を、グリッドに分割することで離散的な表現に落とす。</p>
<p><span class="math inline">\(\Delta\)</span>はラプラシアンと呼ばれる二階微分演算子で、二次元なら以下で定義される。</p>
<p><span class="math display">\[
\Delta \equiv \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}
\]</span></p>
<p>今は二次元空間を考えているが、まずは一次元の世界<span class="math inline">\(f(x)\)</span>を考える。微分方程式に二階微分が含まれているので、二階微分を近似したい。そのために、<span class="math inline">\(f(x+h)\)</span>と<span class="math inline">\(f(x-h)\)</span>をそれぞれ二次までテイラー展開してみよう。</p>
<p><span class="math display">\[
\begin{aligned}
f(x + h) &amp;= f(x) + f&#39;(x)h + \frac{h^2}{2} f&#39;&#39;(x) + O(h^3) \\
f(x - h) &amp;= f(x) - f&#39;(x)h + \frac{h^2}{2} f&#39;&#39;(x) + O(h^3)
\end{aligned}
\]</span></p>
<p>両辺足すと<span class="math inline">\(f&#39;(x)\)</span>の項が消えるので、整理して</p>
<p><span class="math display">\[
f&#39;&#39;(x) = \frac{f(x+h) - 2 f(x) + f(x-h)}{h^2}
\]</span></p>
<p>を得る。全く同様にして、二変数関数の二階微分(ラプラシアン)は、以下のように表現できる。</p>
<p><span class="math display">\[
\Delta f(x,y) \sim \frac{f(x+h,y)+f(x-h,y)+f(x,y+h)+f(x,y-h)-4f(x,y)}{h^2}
\]</span></p>
<p>簡単のため、<span class="math inline">\(h=1\)</span>としよう。空間の離散化により<span class="math inline">\(f(m, n)\)</span>の値を二次元配列<code>s[m][n]</code>で表現する。すると、位置<span class="math inline">\((m,n)\)</span>におけるラプラシアンは、この配列<code>s</code>を用いて</p>
<p><code>s[m+1][n] + s[m-1][n] + s[m][n+1] + s[m][n-1] - 4 * s[m][n]</code></p>
<p>と表現できる。これは、前後左右のセルの値の合計から、自分の値の4倍を引いたものであり、自分が「まわりの平均」よりも大きい時に負、小さい時に正となる。このように、ラプラシアンは「なるべくまわりに合わせよう、全体を平均化しよう」という働きをする。</p>
<div class="figure">
<img src="fig/procedure.png" alt="差分計算の流れ" />
<p class="caption">差分計算の流れ</p>
</div>
<p>もともとの式のうち、時間微分は一次の差分を取ることで計算する。その時間発展にはラプラシアンという空間微分が含まれているが、それについては中央差分で近似した。これで数値計算に必要な式がすべて揃った。</p>
<h1 id="数値シミュレーション課題">数値シミュレーション:課題</h1>
<h2 id="課題1反応拡散方程式">課題1:反応拡散方程式</h2>
<p>反応拡散方程式を数値的に解いてみよう。新しいPython3ノートブックを開き、<code>gs.ipynb</code>という名前で保存せよ。</p>
<h3 id="ライブラリのインポート">1. ライブラリのインポート</h3>
<p>最初のセルで、必要なライブラリのインポートをしよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> numba <span class="im">import</span> jit
<span class="im">from</span> matplotlib <span class="im">import</span> animation, rc</code></pre></div>
<h3 id="ラプラシアンの実装">2. ラプラシアンの実装</h3>
<p>二次元配列<code>s[m][n]</code>の、位置<span class="math inline">\((m,n)\)</span>におけるラプラシアンは、</p>
<p><code>s[m+1][n] + s[m-1][n] + s[m][n+1] + s[m][n-1] - 4 * s[m][n]</code></p>
<p>と表現できる。これを用いて、二次元配列<code>s</code>と位置<code>m,n</code>を受け取って、その位置でのラプラシアンの値を返す関数<code>laplacian</code>を実装したい。以下はそれを途中まで実装したものだ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> laplacian(m, n, s):
    ts <span class="op">=</span> <span class="fl">0.0</span>
    ts <span class="op">+=</span> s[m<span class="op">+</span><span class="dv">1</span>][n]
    ts <span class="op">+=</span> s[m<span class="op">-</span><span class="dv">1</span>][n]
    ts <span class="op">+=</span> s[m][n<span class="op">+</span><span class="dv">1</span>]
    ts <span class="op">+=</span> s[m][n<span class="op">-</span><span class="dv">1</span>]
    <span class="co"># ここを埋めよ</span>
    <span class="cf">return</span> ts</code></pre></div>
<p>上記がラプラシアンの値となるように、未完成の部分を完成させよ。</p>
<p>なお、関数定義の前に<code>@jit</code>とあるのは、「この関数をJITコンパイルせよ」という指示(デコレータ)である。JITはJust in Timeの略で、実行時にコードをコンパイルすることでコードの実行を加速する。ここではJIT、デコレータともに詳細には触れない。</p>
<h3 id="ラプラシアンのテスト">3. ラプラシアンのテスト</h3>
<p><code>laplacian</code>を実装したらテストしてみよう。以下はすべて三つ目のセルで実行せよ。</p>
<p>まず、<code>laplacian</code>に食わせるテスト用のNumPy二次元配列を作成する。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
a</code></pre></div>
<p>実行すると以下のような表示になるはずである。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">array([[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>],
       [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>],
       [<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]])</code></pre></div>
<p>さて、中央に着目しよう。中央の値は4であり、1,3,5,7に囲まれている。周りの4つの数字の平均は4であり、中央の値と一致するため、この地点でのラプラシアンの値は0になるはずである。確認してみよう。三つ目のセルを以下のように書き換えよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
laplacian(<span class="dv">1</span>,<span class="dv">1</span>,a)</code></pre></div>
<p>これは、<code>a</code>という配列の<code>(1,1)</code>地点におけるラプラシアンの中央差分の値を求めよ、という意味である。実行結果として<code>0.0</code>が返ってくれば正しい。</p>
<p>これだけではテストとして不安なので、値を少しずらしてみよう。三つ目のテスト用セルを以下のように修正して実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
a[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span>
a</code></pre></div>
<p>まず、入力するリストが以下のような形になる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[[<span class="dv">0</span> <span class="dv">0</span> <span class="dv">2</span>]
 [<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>]
 [<span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span>]]</code></pre></div>
<p>4の上が1であったのが0になった。したがって、中央は平均よりも高い値になっているから、ラプラシアンは負になるはずである。実際に計算してみよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
a[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span>
laplacian(<span class="dv">1</span>,<span class="dv">1</span>,a)</code></pre></div>
<p>上記の実行結果が<code>-1.0</code>になれば正しく計算されている。</p>
<h3 id="時間発展">4. 時間発展</h3>
<p>二つの配列を受け取り、1ステップだけ時間を進める関数<code>calc</code>を実装しよう。以下を4つ目のセルに入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> calc(u, v, u2, v2):
    (L, _) <span class="op">=</span> u.shape
    dt <span class="op">=</span> <span class="fl">0.2</span>
    F <span class="op">=</span> <span class="fl">0.04</span>
    k <span class="op">=</span> <span class="fl">0.06075</span>
    Du <span class="op">=</span> <span class="fl">0.1</span>
    Dv <span class="op">=</span> <span class="fl">0.05</span>
    lu <span class="op">=</span> np.zeros((L, L))
    lv <span class="op">=</span> np.zeros((L, L))
    <span class="cf">for</span> ix <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, L<span class="op">-</span><span class="dv">1</span>):
        <span class="cf">for</span> iy <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, L<span class="op">-</span><span class="dv">1</span>):
            lu[ix, iy] <span class="op">=</span> Du <span class="op">*</span> laplacian(ix, iy, u)
            lv[ix, iy] <span class="op">=</span> Dv <span class="op">*</span> laplacian(ix, iy, v)
    cu <span class="op">=</span> <span class="op">-</span>v<span class="op">*</span>v<span class="op">*</span>u <span class="op">+</span> F<span class="op">*</span>(<span class="fl">1.0</span> <span class="op">-</span> u)
    cv <span class="op">=</span> v<span class="op">*</span>v<span class="op">*</span>u <span class="op">-</span> (F<span class="op">+</span>k)<span class="op">*</span>v
    u2[:] <span class="op">=</span> u <span class="op">+</span> (lu<span class="op">+</span>cu) <span class="op">*</span> dt
    v2[:] <span class="op">=</span> v <span class="op">+</span> (lv<span class="op">+</span>cv) <span class="op">*</span> dt</code></pre></div>
<p>最初の<code>@jit</code>デコレータを忘れないこと。</p>
<h3 id="シミュレーションループ">5. シミュレーションループ</h3>
<p>1ステップ時間を進める関数が書けたら、それを何度も呼び出すことで時間発展をさせよう。また、初期条件として模様の「種」を作る。5つ目のセルに以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> simulation(L, loop):
    u <span class="op">=</span> np.zeros((L, L))
    u2 <span class="op">=</span> np.zeros((L, L))
    v <span class="op">=</span> np.zeros((L, L))
    v2 <span class="op">=</span> np.zeros((L, L))
    h <span class="op">=</span> L<span class="op">//</span><span class="dv">2</span>
    u[h<span class="op">-</span><span class="dv">6</span>:h<span class="op">+</span><span class="dv">6</span>, h<span class="op">-</span><span class="dv">6</span>:h<span class="op">+</span><span class="dv">6</span>] <span class="op">=</span> <span class="fl">0.9</span>
    v[h<span class="op">-</span><span class="dv">3</span>:h<span class="op">+</span><span class="dv">3</span>, h<span class="op">-</span><span class="dv">3</span>:h<span class="op">+</span><span class="dv">3</span>] <span class="op">=</span> <span class="fl">0.7</span>
    r <span class="op">=</span> []
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(loop):
        calc(u, v, u2, v2)
        u, u2, v, v2 <span class="op">=</span> u2, u, v2, v
        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:
          r.append(v.copy())
    <span class="cf">return</span> r</code></pre></div>
<p>これも、最初の行の<code>@jit</code>を忘れないこと。</p>
<h3 id="シミュレーションの実行">6. シミュレーションの実行</h3>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">imgs <span class="op">=</span> simulation(<span class="dv">64</span>, <span class="dv">10000</span>)
n <span class="op">=</span> <span class="bu">len</span>(imgs)
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):
  im <span class="op">=</span> plt.imshow(imgs[n<span class="op">//</span><span class="dv">4</span><span class="op">*</span>i])
  plt.show()</code></pre></div>
<p>ここまで正しく入力されていれば、不思議な模様が4枚現れたはずである。</p>
<h3 id="アニメーション">7. アニメーション</h3>
<p>せっかくシミュレーションしたので、アニメーションを表示させよう。そのための準備をする。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">fig <span class="op">=</span> plt.figure()
im <span class="op">=</span> plt.imshow(imgs[<span class="op">-</span><span class="dv">1</span>])
<span class="kw">def</span> update(i):
  im.set_array(imgs[i])</code></pre></div>
<p>実行後、不思議な模様が出力されるはずである。</p>
<h3 id="アニメーションの表示">8. アニメーションの表示</h3>
<p>ではアニメーションを表示してみよう。以下を実行せよ(少し時間がかかる)。画像の下に操作パネルが出たら、再生ボタン(右向きの三角)を押してみよう。アニメーションが表示されたら成功である。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">rc(<span class="st">&#39;animation&#39;</span>, html<span class="op">=</span><span class="st">&#39;jshtml&#39;</span>)
animation.FuncAnimation(fig, update, interval<span class="op">=</span><span class="dv">50</span>, frames<span class="op">=</span><span class="bu">len</span>(imgs))</code></pre></div>
<h2 id="発展課題機械学習">発展課題：機械学習</h2>
<p>せっかくなので、簡単な機械学習を経験してみよう。題材として敵対的生成ネットワーク、GAN (Generative Adversarial Networks)を取り上げる。これは、偽造者(Generator)と鑑定者(Discriminator)がお互いに切磋琢磨させることで、偽造者に本物そっくりの画像を生成させるようにする手法である。</p>
<p>新しいノートブックを開き<code>gan.ipynb</code>として保存せよ。</p>
<h3 id="tensorflowのインストール">1. TensorFlowのインストール</h3>
<p>Google ColabではデフォルトでTensorFlowが使えるが、今回はやや古いバージョンを使いたいので、バージョンを指定してインストールをする。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">%</span>tensorflow_version <span class="fl">1.</span>x
<span class="op">!</span>pip install tensorflow<span class="op">==</span><span class="fl">1.13</span>.<span class="dv">1</span></code></pre></div>
<p>最初の<code>%</code>から始まる行はマジックコメントと呼ばれ、Google Colabに「これからバージョン1.0系を使うよ」という指示をする。</p>
<pre class="txt"><code>Successfully installed mock-3.0.5 tensorboard-1.13.1 tensorflow-1.13.1 tensorflow-estimator-1.13.0</code></pre>
<p>と表示されれば正しくインストールされている。</p>
<h3 id="サンプルプログラムのダウンロード">2. サンプルプログラムのダウンロード</h3>
<p>GANのプログラムは、簡単なものでもそれなりに長いコードを記述する必要がある。今回は既に入力されたプログラムをダウンロードしよう。以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">!</span>wget https:<span class="op">//</span>kaityo256.github.io<span class="op">/</span>python_zero<span class="op">/</span>gan<span class="op">/</span>gan_test.py</code></pre></div>
<p><code>‘gan_test.py’ saved [4500/4500]</code>と表示されればダウンロード完了です。</p>
<h3 id="インポート">3. インポート</h3>
<p>先程ダウンロードしたプログラムをインポートしよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> gan_test</code></pre></div>
<p>実行時に多数の<code>FutureWarning</code>が出るが、気にしなくて良い。これでGANが使えるようになった。</p>
<h3 id="データのダウンロード">4. データのダウンロード</h3>
<p>GANでは、まず「正解の画像」をデータセットとして与える必要がある。偽造者は、その画像に似せて絵を描いていく。逆に、与えるデータによって「好きな画家」を模写できるように学習させることができる。本講義では、三つのデータセットを用意した。</p>
<ul>
<li><code>mnist.tfrecord</code> 手書きの数字(MNIST)</li>
<li><code>fontawesome.tfrecord</code> Font Awesomeというフォントのシンボルアイコン10種類</li>
<li><code>hiragana.tfrecord</code> ひらがなすべて(IPAゴシックフォント)</li>
</ul>
<p>上記のうち、好きなものを一つ選んで<code>TRAIN_DATA</code>とし、ダウンロードすること。数字は学習が容易だが、ひらがなは難しく、シンボルはその中間、といった特徴がある。</p>
<p>以下は手書きの数字(MNIST)を選んだ場合の例である。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">TRAIN_DATA <span class="op">=</span> <span class="st">&quot;mnist.tfrecord&quot;</span>
url<span class="op">=</span><span class="st">&quot;https://kaityo256.github.io/python_zero/gan/&quot;</span>
<span class="bu">file</span><span class="op">=</span>url<span class="op">+</span>TRAIN_DATA
<span class="op">!</span>wget $file</code></pre></div>
<h3 id="ganの実行">5. GANの実行</h3>
<p>ではいよいよGANの実行をしてみよう。以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">gan_test.run_gan(TRAIN_DATA)</code></pre></div>
<p>最初に</p>
<pre class="txt"><code>WARNING: The TensorFlow contrib module will not be included in TensorFlow 2.0.</code></pre>
<p>といった警告が出るが、気にしないで良い。</p>
<p>画面には、数十秒ごとに偽造者が作成した画像が表示されていく。最初は完全なノイズにしか見えなかった画像が、学習が進むにつれて偽造者が「腕を上げていく」様子が見えるであろう。学習が終わったら(もしくは途中で止めて)、別の画像でも学習させてみよ。</p>
<h2 id="余談パーソナルスーパーコンピュータ">余談：パーソナルスーパーコンピュータ</h2>
<p>パソコンとは「パーソナルコンピュータ」の略、つまり「個人向け計算機」という意味だ。もともと計算機は貴重品かつ大型であり、組織に一つしかないものだった。それが徐々に小型化し、オフィスに一つ(オフコン)になり、さらに個人で独占して利用できるものになった。パソコンが普及するにつれて、もともと「組織に一つ」しかないような巨大な計算機は「スーパーコンピュータ(スパコン)」と呼ばれ、パソコンと区別されるようになった。スパコンは、安くて一億、高ければ数十、数百億円といったその価格もさることながら、その維持も大変である。計算するのには莫大な電気が必要で、かつ使った電気はすべて熱となるからそれを冷却するシステムも必要である。したがって、本来「パソコン」と「スパコン」は相容れない概念のはずだが、スパコンを個人で所有することでその二つを悪魔合体させ、「パーソナルスーパーコンピュータ」という狂った概念を生み出した人がいる。桑原邦郎氏である。彼は流体力学を専門とする研究者で、親から受け継いだ莫大な財産をすべてスパコンに突っ込んだ。東京大学工学部物理工学科の助手、宇宙科学研究所の助教授を経て、自宅に計算流体力学研究所という研究所を作り、そこにスパコンを購入して運用した。最盛期は七台のスパコンがフル稼働し、電気代だけで月に2000万円かかったという。1980年代後半から1990年代にかけて、計算流体力学を専門とする人はほとんど彼のパーソナルスパコンにお世話になったと思われる。自動車メーカも技術者を派遣していたそうだ。また、米国の諜報機関が「軍事目的に使っているのではないか」と疑ったとのエピソードもある。彼は親から受け継いだ莫大な遺産をすべてスパコンに突っ込み、それを惜しげもなくいろんな人に使わせた。</p>
<p>それから紆余曲折あって、計算流体力学研究所はスパコンを手放し、技術コンサルやパソコンの組み立て、販売をする会社となった。私が大学院に進学した際に与えられたパソコンは、この計算流体力学研究所で購入したAlpha21164のマシンであった。指導教員の「せっかくだから組み立てさせてもらったら？」の言葉に甘え、目黒に行ってアルバイトのお兄さんと一緒に自分の研究に使うマシンを組み立てた。そこに社長である桑原氏が様子を見にやってきた。僕が物工の学生と知ると、興味をもっていろいろ聞いてきた。僕はまさか目の前の社長さんが元物工の助手だったなんて知らなかったので「物工のご出身なんですか？どこの研究室ですか？」と的外れな質問をした。彼はただ笑って何も答えなかったのを思い出す。その時は青二才で何もわからなかった私だが、スパコンを使って研究をするようになった今なら、彼からいろいろ興味深い話が聞けたのではないかと残念に思う。桑原氏は2008年、その豪快な生涯を閉じた。「親の遺産をもっとも有効に学術に活かした」と評されている。</p>
</article>
</body>
</html>
