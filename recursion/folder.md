# 再帰呼出し(フォルダとファイルによる説明)

例えばあるフォルダ以下にある全てのファイルの合計を知りたいとする。フォルダの中にはフォルダがあるかもしれず、さらにそのフォルダの中にもフォルダがあるかもしれない。フォルダとファイルを定義すると、以下のようになる。

* ファイルシステムには、フォルダとファイルの二種類の構造が存在する
* フォルダは、0個以上のフォルダかファイル、もしくはその両方を持つ

フォルダの定義にフォルダが表れることに注意しよう。このように、何かの定義にそれ自身が現れることを「再帰的定義」と呼ぶ。フォルダはフォルダを持つことができ、さらにそのフォルダもフォルダを持つ可能性が・・・と、フォルダは入れ子構造になっていることがわかる。再帰的定義はこのような入れ子構造を作る。再帰処理はこうした「入れ子構造」を持つ状態を扱うのに適している。

いま、あるフォルダ以下にある全てのファイル数の合計を知りたいとしよう。例えば以下のようなフォルダ構造があるとする。

![folder.png](fig/folder.png)

最初のフォルダは２つのフォルダと1つのファイルを持ち、２つ目のフォルダはさらにサブフォルダがあり・・・という構造になっている。この構造を、入れ子構造を持つリストで表現してみよう。

```py
[[3],[[4],2],1]
```

数字がファイル数、リストがフォルダを表している。このリストは何重にも入れ子構造になる可能性がある。先程の「フォルダに含まれるファイルの総数を調べる」とは、この「リストに含まれる数字の合計を知りたい」という問題と等価である。

この問題は以下のように考える。まず、ファイル(整数)かフォルダ(リスト)を与えられたら、そのサブフォルダも含めたすべてのファイル数を返す関数、`num_files`という関数を考える。もし与えられたのが整数であれば、それをそのまま返せば良い。もしリストだったら、その要素すべてに対して`num_files`を呼んでやり、その返り値の合計を返せば良い。以上を実装すると以下のようになる。

```py
def num_files(f):
    if isinstance(f, int):
        return f
    s = 0
    for i in f:
        s += num_files(i)
    return s
```

新しいノートブックを開き、上記を入力せよ。

その上で次のセルに

```py
a = [[3],[[4],2],1]
num_files(a)
```

を実行し、正しい答え10が表示されることを確認せよ。他にも様々な入れ子になったリスト構造を渡し、正しく動作することを確認せよ。

これは、以下のように動いている。

1. まず、最初(第一階層)の`num_files`に渡されたリストは`[[3],[[4],2],1]`である。これは整数ではないので、for文に処理がわたり、`[3]`, `[[4],2]`, `[1]`の三つに要素が分割され、それぞれが`num_files`に渡される
2. `[3]`を渡された第二階層の`num_files`は、やはり整数ではないのでその中身`3`を`num_files`に渡す
3. `3`を渡された第三階層の`num_files`は、整数なのでそれをそのまま第二階層の`num_files`に返す
4. 第二階層の`num_files`は、`num_files(3)`の結果として3を得たので、それをそのまま帰す
5. これにより第一階層の`num_files`は`num_files([3])`の結果として3を得たので、それを`s`に加える

同様に、`num_files([[4],2])`の結果として6、`num_files([1])`の結果として1が返ってくるので、第一階層の`num_files([[3],[[4],2],1])`は3+6+1として10を返す。これが欲しい結果であった。

![folder2.png](fig/folder2.png)

再帰のコツは、「いつ再帰が終わるか」をちゃんと考えることである。`num_files`は、整数が渡されたら`return`を、リストが渡されたら再度`num_files`を呼ぶ。再帰処理は自然に木構造を作るが、その一番末端のノード(葉と呼ぶ)は、この場合は整数を渡された場合である。上記の木構造の「葉」が、必ずファイル(整数)になっていることに注意せよ。再帰は終端処理を間違えると無限に再帰してしまう。

ここではフォルダに含まれるファイルの総数を考えたが、他にも将棋などのボードゲームの思考ルーチンなども自然に再帰が使われる。将棋を指すことを考えよう。現在の盤面から何か手を進めたら、相手がどう打ってくるか予想し、さらにそれに対して自分はどう打つか予想し・・・と、「将棋の盤面を見て次に打つ手を考える」ことを考えるであろう。このように将棋にも「入れ子構造」が表れる。

再帰呼出しは、うまくハマるとプログラムがきれいに組めて気持ちが良いのだが、慣れていないとバグを入れたり、終了処理を間違えて無限に再帰してスタックオーバーフローでプログラムを落としたりしがちである。今回は、簡単なゲームを題材に、再帰呼出しを用いたプログラムを実装してみよう。