<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>

<style>
    .btn-square {
      display: inline-block;
      padding: 0.5em 0.5em;
      text-decoration: none;
      background: #668ad8;
      color: #FFF;
      border-bottom: solid 4px #626295;
      border-radius: 5px;
    }

    .btn-square:active {
      -webkit-transform: translateY(4px);
      transform: translateY(4px);
      border-bottom: none;
    }
  .markdown-body {
    box-sizing: border-box;
    min-width: 200px;
    max-width: 980px;
    margin: 0 auto;
    padding: 45px;
  }
  p.caption{
    display:none;
  }
  img {width: 100%}

  @media (max-width: 767px) {
    .markdown-body {
      padding: 15px;
    }
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>
<body>
<article class="markdown-body">
<h1 id="再帰呼び出し"><a href="https://kaityo256.github.io/python_zero/recursion/">再帰呼び出し</a></h1>
<p><a href="../index.html">[Up]</a> <a href="https://github.com/kaityo256/python_zero">[Repository]</a></p>
<h2 id="本講で学ぶこと">本講で学ぶこと</h2>
<ul>
<li>再帰呼び出しとは</li>
<li>階段の登り方問題</li>
<li>迷路</li>
</ul>
<h2 id="再帰呼び出しとは">再帰呼び出しとは</h2>
<p>例えばパソコンを使っているとフォルダを扱うであろう。フォルダを開くと、その中にはやはりフォルダとファイルが含まれる。この事実をもって「フォルダ」という言葉を定義しようとすると「フォルダとは、フォルダとファイルを含むものである」となる。「フォルダ」の記述に、定義したい言葉である「フォルダ」が含まれていることがわかる。このように、何かの中に、その何かそのものが現れることを <strong>再帰(Recursion)</strong> と呼び、何かの定義に自分自身が現れることを <strong>再帰的定義(Recursive Definition)</strong> と呼ぶ。</p>
<div class="figure">
<img src="fig/folder.png" alt="フォルダの再帰的定義" />
<p class="caption">フォルダの再帰的定義</p>
</div>
<p>プログラムにおける再帰とは、簡単に言ってしまえば「自分自身を呼び出す関数」のことである。プログラムにおいて関数の実装は「この関数が呼び出されたらこのような処理をせよ」という、定義にほかならない。ある関数の定義に、その関数そのものが含まれるので、これは再帰的な記述になっている。このように関数が自分自身を呼び出すことを <strong>再帰呼び出し(Recursive Call)</strong> と呼ぶ。以下、再帰予び出しを用いるアルゴリズムやプログラムを総称して単に「再帰」と呼ぶ。</p>
<p>再帰は慣れると極めて強力なアルゴリズムであり、中級以上のプログラマになるためには必須のプログラミング技法である。しかし、プログラムの初学者にとって再帰はループ構造や制御構造に比べてその動作ステップをイメージしづらく、「初学者の壁」となっている。今回はそんな「再帰呼出し」を学ぶが、再帰はなんども組んでいるうちにおぼろげに感覚を掴んでくるものであって、たった一回の講義で理解することは難しい。とりあえず、以下の「再帰三カ条」だけを覚えておいて欲しい。</p>
<p>再帰三カ条</p>
<ul>
<li>再帰とは、自分自身を呼び出す関数である</li>
<li>関数の最初に「終端条件」を記述する</li>
<li>「解きたい問題より小さな問題」に分解して自分自身を呼び出す</li>
</ul>
<p>必ずしも上記の形に当てはまらない再帰もあるが、それはその時に学べばよい。まずは上記三カ条が再帰の基本だと覚えておけばよい。</p>
<p>簡単な例として、自然数nの階乗を返す関数<code>fact(n)</code>を考えてみよう。これは1からnまでの数の積だ。</p>
<p><span class="math display">\[
n! = 1 \cdot 2 \cdots n-1 \cdot n
\]</span></p>
<p>これをプログラムで計算したい。もちろん、以下のようにループを回してしまうのが簡単だ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> fact(n):
    a <span class="op">=</span> <span class="dv">1</span>
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):
        a <span class="op">*=</span> i
    <span class="cf">return</span> a</code></pre></div>
<p>しかし、ここでは再帰の考え方を学ぶためにあえて再帰で書いてみよう。</p>
<p>再帰プログラムの基本は「今解きたい問題よりも小さな問題の答えがすべてわかっている場合、いま解きたい問題の答えはどう記述できるだろうか？」という考え方である。</p>
<p>nの階乗の値、<code>fact(n)</code>の値を知りたい時、もし(n-1)の階乗の値<code>fact(n-1)</code>がわかっているとしよう。すると、欲しい値はそれにnをかけたものだ。つまり、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">fact(n) <span class="op">=</span> n <span class="op">*</span> fact(n<span class="op">-</span><span class="dv">1</span>)</code></pre></div>
<p>である。関数のある値を得るのに、その関数自身を使っている、再帰的な記述になっているのがわかるであろう。</p>
<p>さて、<code>fact(n-1)</code>の値は<code>fact(n-2)</code>にn-1をかけたものであり、<code>fact(n-2)</code>は<code>fact(n-3)</code>の値にn-2をかけたもので・・・とどんんどん<code>fact</code>の中身が小さくなり、いつかは<code>fact(1)</code>になるであろう。1の階乗は1であり、ここで終了である。</p>
<p>以上から、階乗を求めるプログラムを再帰を使って書くとこうなる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> fact(n):
    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:
        <span class="cf">return</span> <span class="dv">1</span>
    <span class="cf">return</span> n <span class="op">*</span> fact(n<span class="op">-</span><span class="dv">1</span>)</code></pre></div>
<p>これが、先ほどの「再帰三カ条」に従っていることを確認しよう。</p>
<ul>
<li>再帰とは、自分自身を呼び出す関数である</li>
<li><code>fact</code>の定義に、<code>fact</code>自身が使われている</li>
<li>関数の最初に「終端条件」を記述する</li>
<li>引数<code>n</code>として1が指定されたら1を返して終了</li>
<li>「解きたい問題より小さな問題」に分解して自分自身を呼び出す</li>
<li>自分が受け取った引数<code>n</code>に対して、<code>n-1</code>を引数として自身を呼び出している</li>
</ul>
<div class="figure">
<img src="fig/recursion3.png" alt="再帰三カ条" />
<p class="caption">再帰三カ条</p>
</div>
<p>実際にこの関数<code>fact</code>の動作を見てみよう。例えば<code>fact(3)</code>として呼び出すことを考える。</p>
<ol style="list-style-type: decimal">
<li>まず3は1ではないので終端条件にはマッチせず、<code>fact(2)</code>が呼ばれる</li>
<li>同様に<code>fact(1)</code>が呼ばれる</li>
<li><code>n</code>として1が代入されて呼ばれた<code>fact(1)</code>は、終端条件にマッチして1を返す</li>
<li><code>fact(1)</code>を呼んだ<code>fact(2)</code>は、<code>fact(1)</code>の返り値1に2をかけた2を返す</li>
<li><code>fact(2)</code>を呼んだ<code>fact(3)</code>は、<code>fact(2)</code>の返り値2に3をかけた6を返して値が確定</li>
</ol>
<div class="figure">
<img src="fig/roundtrip.png" alt="再帰の動作" />
<p class="caption">再帰の動作</p>
</div>
<p>つまり、再帰関数はどんどん問題を小さくしながら自分自身を呼び出していき、どこかで「終端条件」に達すると、そこから呼び出し履歴を逆にたどりながら帰ってくる。標語的に言えば「再帰は行って返って」くる。この「問題を棚上げしながら単純化していき、どこかで終端条件に達したら、これまで棚上げにした問題を解決しながら戻ってくる」という感覚を身につけることが再帰プログラムの肝である。</p>
<h2 id="階段の登り方問題">階段の登り方問題</h2>
<p>先程の階乗を求める問題は、あまりに簡単過ぎて再帰を使うメリットが感じられなかったであろう。そこで、もう少し複雑な問題として「階段の登り方問題」を考えよう。</p>
<p>いま、目の前に<span class="math inline">\(n\)</span>段の階段があるとする。一度に1段、もしくは2段登るやり方を混ぜて登る時、「登り方の総数」は全部で何通りあるだろうか？</p>
<div class="figure">
<img src="fig/kaidan.png" alt="階段の登り方問題" />
<p class="caption">階段の登り方問題</p>
</div>
<p>まずは<span class="math inline">\(n\)</span>が小さい時の場合を考えてみよう。<span class="math inline">\(n=1\)</span>の時、つまり1段しかない時には、1段で登るしかないので1通りである。2段ある場合は、1段ずつ2回で登るか、2段で一度に登るかの2通りである。ここで、1もしくは2をいくつか足して、その合計をNにするようなやり方を数えれば良い、ということに気がつくであろう。例えば<span class="math inline">\(n=3\)</span>なら、</p>
<p><span class="math display">\[
\begin{aligned}
3 &amp;= 1 + 1 + 1\\
3 &amp;= 1 + 2 \\
3 &amp;= 2 + 1
\end{aligned}
\]</span></p>
<p>の3通りである。<span class="math inline">\(n=4\)</span>なら、</p>
<p><span class="math display">\[
\begin{aligned}
4 &amp;= 1 + 1 + 1 + 1\\
4 &amp;= 1 + 1 + 2 \\
4 &amp;= 1 + 2 + 1 \\
4 &amp;= 2 + 1 + 1 \\
4 &amp;= 2 + 2 \\
\end{aligned}
\]</span></p>
<p>の5通りである。さて、これを一般化して、<span class="math inline">\(n\)</span>段の時の登り方<span class="math inline">\(F_n\)</span>はどのように求めればよいだろうか？このような場合に「再帰的」な考え方をする。</p>
<p>再帰プログラムの基本は「今解きたい問題よりも小さな問題の答えがすべてわかっている場合、いま解きたい問題の答えはどう記述できるだろうか？」と考えることであった。今、<span class="math inline">\(n-1\)</span>段までの登り方、<span class="math inline">\(F_1, F_2, \cdots F_{n-1}\)</span>が全てわかっているとしよう。その知識を使って、<span class="math inline">\(F_n\)</span>の値を求められないだろうか？</p>
<p>最初のステップを考えよう。眼の前に<span class="math inline">\(n\)</span>段の階段がある。できることは、1段登るか、2段登るかの二通りである。さて、1段登ったら、残りは<span class="math inline">\(n-1\)</span>段であるから、その登り方は<span class="math inline">\(F_{n-1}\)</span>通りである。2段登ったら残りは<span class="math inline">\(n-2\)</span>段であるから、その登り方は<span class="math inline">\(F_{n-2}\)</span>通りである。最初のステップでできることはこの二つしかなく、それらは重複しないので、階段の登り方の総数はその二通りの和である。</p>
<p>ここから、漸化式</p>
<p><span class="math display">\[
F_n = F_{n-1} + F_{n-2}
\]</span></p>
<p>が成り立つことがわかる。さて、左辺にも右辺にも「登り方<span class="math inline">\(F\)</span>」が登場する。つまり、ある<span class="math inline">\(F\)</span>を、別の引数をもった<span class="math inline">\(F\)</span>自身で、再帰的に表現していることがわかる。さらに、左辺に比べて右辺は問題サイズ<span class="math inline">\(n\)</span>が小さいことがわかるであろう。つまり、ある大きさ<span class="math inline">\(n\)</span>をもつ問題が、それより小さいサイズの<span class="math inline">\(n-1\)</span>と<span class="math inline">\(n-2\)</span>という問題を解くことに帰着された。これが再帰の考え方である。すなわち、再帰アルゴリズムは本質的に<strong>分割統治法</strong>である。</p>
<p>後の課題で階段の登り方問題を実装し、それがどうやって「行って帰って」来るかを見てみよう。</p>
<h2 id="迷路">迷路</h2>
<p>再帰のもう少し実用的(？)な例として、迷路を解くプログラムを考えよう。迷路が与えられた時に、スタート地点からゴール地点までの経路を探索するのが目的である。</p>
<p>このような探索で問題となるのが、「分かれ道」の存在である。いま、分かれ道に直面したとしよう。どちらが正解かわからないので、とりあえず現在地を覚えておいて、片方の道を試し、もしその先が行き止まりなら先程覚えておいた位置まで戻ってきて、別の道を試す必要がある。もし試しに選んだ片方の道の先にまた分かれ道があったら、また現在地を覚えておいて、片方を試す、という行動を繰り返す。</p>
<p>このように「とりあえずあっちへ進んで、ダメなら戻る」という行動を繰り返すようなアルゴリズムを <strong>バックトラック(backtracking)</strong> と呼ぶ。将棋や囲碁のようなゲームで「先の手を読む」場合や、ナンプレなどのようなゲームで数字を仮り置きして矛盾したら戻ってやりなおす場合など、広く使われるアルゴリズムなので、これまでも無意識に使ったことはあるだろう。</p>
<div class="figure">
<img src="fig/backtracking.png" alt="バックトラックアルゴリズム" />
<p class="caption">バックトラックアルゴリズム</p>
</div>
<p>このような「とりあえずあっちへ進んで、ダメなら戻る」というバックトラックは、再帰を使うときれいに書ける。このバックトラックを使って迷路を解くアルゴリズムを考えよう。</p>
<p>単にゴールにたどり着くだけなら、「矢印」を残しながら進んでいけば良い。例えばこんなアルゴリズムになる。</p>
<ul>
<li>自分の進む向きに矢印を書きながら進む</li>
<li>分かれ道に来たら、とりあえずどちらかを選ぶ</li>
<li>進んだ先が行き止まりになったら、矢印を逆向きに戻る</li>
<li>戻っている時に、まだ試していない道があったらそちらを選ぶ</li>
</ul>
<div class="figure">
<img src="fig/bt_maze1.png" alt="バックトラックによる迷路探索" />
<p class="caption">バックトラックによる迷路探索</p>
</div>
<p>戻る時、つまり矢印と逆向きに進んでいる時にまだ試してない道を見つけたら必ずそこを試すのがポイントである。これにより、「戻っている時には、その後ろにある経路はすべて探索済みである」つまり、「道の見落としが無い」ということが保証される。バックトラックで迷路探索とは、要するに「見落としが無いようにしらみつぶしに探しましょう」ということを言っているに過ぎない。</p>
<p>このように、とりあえず進めるだけ進んで、行き止まりに行き当たったら戻ってくる、というような探索アルゴリズムを <strong>深さ優先探索(depth-first search)</strong> と呼ぶ。逆に、自分がいまいる地点から徐々に探索範囲を広げながら探索する方法を <strong>幅優先探索(breadth first search)</strong> と呼ぶ。ここでは深入りしないが、「そういう用語がある」ということだけぼんやり覚えておけば良い。</p>
<p>さて、単にゴールにたどり着くだけなら上記の方法で良いが、ゴールまでの経路を求めるには少し工夫が必要だ。方針としては、「スタート地点からの距離」を各部屋に記しながら進んで行く。探索が終わったら、全ての場所に「スタート地点からの距離」があるはずである。この状態でゴールから、「数字が減るように」進んでいく。分かれ道では「カウントが減る方」がスタートに至る道であるから、そちらを選び続ければ「ゴールからスタートへの道」が完成する。</p>
<div class="figure">
<img src="fig/bt_maze2.png" alt="バックトラックによる迷路探索" />
<p class="caption">バックトラックによる迷路探索</p>
</div>
<p>課題では、指定された迷路について、「スタート地点からの距離地図」の作成、及び「距離地図が完成した後に解の経路作成」のそれぞれの処理を再帰で実装しよう。</p>
<h1 id="再帰呼び出し課題">再帰呼び出し：課題</h1>
<h2 id="課題1階段の登り方問題">課題1：階段の登り方問題</h2>
<p>階段を、一度に1段、もしくは2段登るやり方を混ぜて登る時、「<span class="math inline">\(n\)</span>段の階段の登り方の総数」を返す関数<code>kaidan(n)</code>を作り、その動作を可視化してみよう。新しいノートブックを開き、<code>kaidan.ipynb</code>として保存せよ。</p>
<h3 id="課題1-1再帰の実装">課題1-1：再帰の実装</h3>
<h4 id="ライブラリのインポート">1. ライブラリのインポート</h4>
<p>直接再帰には関係ないが、後で再帰木を可視化をするために必要なライブラリをインポートしておこう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">from</span> graphviz <span class="im">import</span> Digraph
<span class="im">import</span> IPython</code></pre></div>
<h4 id="再帰関数kaidanの実装">2. 再帰関数<code>kaidan</code>の実装</h4>
<p>2つ目のセルに、<code>n</code>段の階段の登り方を返す関数<code>kaidan(n)</code>を実装せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> kaidan(n):
    <span class="co"># ここを埋めよ</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> kaidan(n):
    <span class="co"># 終端条件</span>
    <span class="cf">if</span> 条件:
        <span class="cf">return</span> 値
    <span class="co"># 再帰部分</span>
    <span class="cf">return</span> 自分自身を使った式</code></pre></div>
<p>実装すべきは終端条件と再帰部分である。以下を参考にせよ。</p>
<ul>
<li>階段の段数が1の場合と2の場合が終端条件に該当する。それぞれどんな値を返すべきか？</li>
<li>終端条件に該当しない場合は、<code>kaidan(n-1)</code>と<code>kaidan(n-2)</code>の和を返す</li>
</ul>
<p>終端条件が二つあることに注意すること。</p>
<h4 id="kaidanの確認">3. <code>kaidan</code>の確認</h4>
<p>関数<code>kaidan</code>が実装できたら動作確認をしてみよう。3つ目のセルで以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">kaidan(<span class="dv">3</span>)</code></pre></div>
<p>答えが3になっただろうか？また、<code>kaidan(4)</code>が5に、<code>kaidan(5)</code>が8になることを確認せよ。<code>kaidan(10)</code>の値はどうなるだろうか？</p>
<h3 id="課題1-2再帰木の表示">課題1-2：再帰木の表示</h3>
<p>再帰プログラムの難しさは、「プログラムがどのように実行されるかが分かりづらい」という点にある。繰り返すや条件分岐はそのままたどれば良いのだが、再帰プログラムは何度も自分を呼び出し、そして呼び出し先から返ってくる。この振る舞いを可視化してみよう。</p>
<h4 id="再帰木の可視化関数kaidan_gの実装">4. 再帰木の可視化関数<code>kaidan_g</code>の実装</h4>
<p>4つ目のセルに以下を実装しよう。これはグラフオブジェクト<code>g</code>を受け取り、階段の登り方がどのように呼び出されているかを可視化する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> kaidan_g(n, g, nodes, parent<span class="op">=</span><span class="va">None</span>):
    index <span class="op">=</span> <span class="bu">str</span>(<span class="bu">len</span>(nodes))
    nodes.append(index)
    g.node(index, <span class="bu">str</span>(n))

    <span class="cf">if</span> parent <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
        g.edge(index, parent)

    <span class="cf">if</span> n <span class="kw">in</span> (<span class="dv">1</span>, <span class="dv">2</span>):
        <span class="cf">return</span>
    kaidan_g(n<span class="op">-</span><span class="dv">1</span>, g, nodes, index)
    kaidan_g(n<span class="op">-</span><span class="dv">2</span>, g, nodes, index)</code></pre></div>
<h4 id="再帰木の可視化">5. 再帰木の可視化</h4>
<p>では、先程実装した<code>kaidan_g</code>を利用して、再帰木を可視化してみよう。5つ目のセルに以下を入力、実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">graph <span class="op">=</span> Digraph(<span class="bu">format</span><span class="op">=</span><span class="st">&quot;png&quot;</span>)
kaidan_g(<span class="dv">5</span>, graph, [])
graph.graph_attr.update(size<span class="op">=</span><span class="st">&quot;10,10&quot;</span>)
graph.render(<span class="st">&quot;test&quot;</span>)
IPython.display.Image(<span class="st">&quot;test.png&quot;</span>)</code></pre></div>
<p>無事に再帰木が表示されただろうか？数字が<code>kaidan(n)</code>として呼び出された<code>n</code>の値である。<code>kaidan(5)</code>は<code>kaidan(4)</code>と<code>kaidan(3)</code>を呼び出し、<code>kaidan(4)</code>は<code>kaidan(3)</code>と<code>kaidan(2)</code>を呼び出し・・・と、再帰的に呼び出しが続いていき、<code>n=1</code>もしくは<code>n=2</code>で呼び出しが止まる(終端条件)ことがわかるであろう。</p>
<p>もし正しく表示されたら、2行目を<code>kaidan_g(8, graph, [])</code>などとして、少し大きな再帰木も表示してみよ。</p>
<h2 id="課題2再帰による迷路の解法">課題2：再帰による迷路の解法</h2>
<h3 id="課題2-1-迷路を解く">課題2-1 迷路を解く</h3>
<h4 id="必要なライブラリのインポート">1.必要なライブラリのインポート</h4>
<p>最初のセルで、必要なライブラリをインポートしておこう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">import</span> IPython
<span class="im">from</span> PIL <span class="im">import</span> Image, ImageDraw
<span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</code></pre></div>
<h4 id="迷路データのダウンロード">2. 迷路データのダウンロード</h4>
<p>次に、迷路データをダウンロードする。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">!</span>wget https:<span class="op">//</span>kaityo256.github.io<span class="op">/</span>python_zero<span class="op">/</span>recursion<span class="op">/</span>maze.pickle</code></pre></div>
<p>これは二次元リストをPickle(漬物)という方法で保存したものだ。</p>
<h4 id="迷路データの可視化">3. 迷路データの可視化</h4>
<p>迷路の状態を可視化し、ファイルに保存する関数<code>save_image</code>を実装しよう。3つ目のセルに以下を実装せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> save_image(maze, filename <span class="op">=</span> <span class="st">&quot;test.png&quot;</span>):
    g <span class="op">=</span> <span class="dv">10</span>
    w <span class="op">=</span> <span class="bu">len</span>(maze)
    h <span class="op">=</span> <span class="bu">len</span>(maze[<span class="dv">0</span>])
    white <span class="op">=</span> (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>)
    im <span class="op">=</span> Image.new(<span class="st">&quot;RGB&quot;</span>, (w<span class="op">*</span>g, h<span class="op">*</span>g), white)
    draw <span class="op">=</span> ImageDraw.Draw(im)
    <span class="cf">for</span> ix <span class="kw">in</span> <span class="bu">range</span>(w):
        <span class="cf">for</span> iy <span class="kw">in</span> <span class="bu">range</span>(h):
            x <span class="op">=</span> ix<span class="op">*</span>g
            y <span class="op">=</span> iy <span class="op">*</span> g
            s <span class="op">=</span> maze[ix][iy]
            color <span class="op">=</span> white
            <span class="cf">if</span> s <span class="op">==</span> <span class="st">&#39;*&#39;</span>:
                color <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
            <span class="cf">elif</span> s <span class="op">==</span> <span class="st">&#39;S&#39;</span>:
                color <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>)
            <span class="cf">elif</span> s <span class="op">==</span> <span class="st">&#39;G&#39;</span>:
                color <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">0</span>)
            <span class="cf">elif</span> s <span class="op">==</span> <span class="st">&#39;+&#39;</span>:
                color <span class="op">=</span> (<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>)
            <span class="cf">if</span> <span class="bu">isinstance</span>(maze[ix][iy], <span class="bu">int</span>):
                color <span class="op">=</span> (<span class="dv">128</span>, <span class="dv">128</span>, <span class="dv">128</span>)
            draw.rectangle((x, y, x<span class="op">+</span>g, y<span class="op">+</span>g), fill<span class="op">=</span>color)
    im.save(filename)
    plt.imshow(Image.<span class="bu">open</span>(filename))</code></pre></div>
<h4 id="迷路データの読み込み">4. 迷路データの読み込み</h4>
<p><code>save_image</code>が正しく実装できたか確認しよう。Pickle(漬物)になっている迷路データを読み込み、表示してみる。以下を4番目のセルで実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;maze.pickle&#39;</span>, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> f:
    maze <span class="op">=</span> pickle.load(f)
save_image(maze)</code></pre></div>
<p>左上にスタート地点(青)、右下にゴール地点(緑)がある迷路が表示されたはずだ。</p>
<h4 id="迷路を解くルーチン">5. 迷路を解くルーチン</h4>
<p>ではさっそく迷路を解く(実際には距離地図を作る)関数<code>solve</code>を書いてみよう。やるべきことは単純で、</p>
<ul>
<li>進もうとした方向が壁<code>*</code>ならそこには行かない</li>
<li>すでに足跡が残っている(<code>maze[x][y]</code>に数字が入っている)なら、そこは探索済みなので行かない</li>
</ul>
<p>というのが終端条件であり、終端条件に該当しない場合は、その場所に足跡を残し、上下左右へ探索すれば良い。</p>
<p>以上をそのまま実装すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> solve(x, y, step, maze):
    <span class="cf">if</span> maze[x][y] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:
        <span class="cf">return</span>
    <span class="cf">if</span> <span class="bu">isinstance</span>(maze[x][y], <span class="bu">int</span>):
        <span class="cf">return</span>
    maze[x][y] <span class="op">=</span> step
    solve(x<span class="op">+</span><span class="dv">1</span>, y, step<span class="op">+</span><span class="dv">1</span>, maze)
    <span class="co"># 残りを埋めよ</span></code></pre></div>
<p><code>isinstance</code>は、与えられたオブジェクト(変数)がどういうタイプかを調べる関数であり、<code>isinstance(a, int)</code>などとすると、オブジェクト<code>a</code>が整数であるかどうかを調べる。ここでは、迷路の指定の場所<code>maze[x][y]</code>に整数が入っているかどうかを調べている。</p>
<p>再帰部分については一部だけ記載されている。これを参考に再帰部分を完成させること。</p>
<h4 id="迷路を解く">6. 迷路を解く</h4>
<p>6つ目のセルで、迷路を解くルーチンを呼び出してみよう。迷路を解いた(<code>solve</code>を呼んだ)後に迷路の状況を可視化するコードである。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">solve(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, maze)
save_image(maze)</code></pre></div>
<p>すべてのセルが灰色(探索済み)になったはずである。</p>
<h4 id="経路探索">7. 経路探索</h4>
<p>さて、探索済みの迷路は、全ての部屋に「入り口からの距離」が書いてある。それを逆にゴールからカウントダウンしながらたどっていけば、それが答えだ。7つ目のセルに以下を実装せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> draw_path(x, y, count, maze):
    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(maze[x][y], <span class="bu">int</span>):
        <span class="cf">return</span>
    <span class="cf">if</span> maze[x][y] <span class="op">!=</span> count:
        <span class="cf">return</span>
    maze[x][y] <span class="op">=</span> <span class="st">&#39;+&#39;</span>
    count <span class="op">-=</span> <span class="dv">1</span>
    draw_path(x<span class="op">+</span><span class="dv">1</span>, y, count, maze)
    draw_path(x<span class="op">-</span><span class="dv">1</span>, y, count, maze)
    draw_path(x, y<span class="op">+</span><span class="dv">1</span>, count, maze)
    draw_path(x, y<span class="op">-</span><span class="dv">1</span>, count, maze)</code></pre></div>
<p>やはり再帰で書いてあるが、ゴールから「目標カウント」を減らしながら進むコードであり、</p>
<ul>
<li>もし足跡のある部屋でなければそこには行かない</li>
<li>目標カウントではない部屋には進まない</li>
</ul>
<p>というのが終端条件である。終端条件に該当しなかった場合は「目標カウント」を残してカウントを減らし、「答えの経路」となるマーク(<code>+</code>)を残して、上下左右の部屋に探索に行く。</p>
<h4 id="解の確認">8. 解の確認</h4>
<p>では解答を表示してみよう。8つ目のセルに以下を入力、実行せよ。ゴールからたどって解の経路をマークする関数<code>draw_path</code>を呼んでから、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">draw_path(<span class="dv">39</span>, <span class="dv">19</span>, maze[<span class="dv">39</span>][<span class="dv">19</span>], maze)
save_image(maze)</code></pre></div>
<p>解答となるパスが赤く表示されたはずだ。</p>
<h3 id="発展課題迷路を解く様子の可視化">発展課題：迷路を解く様子の可視化</h3>
<p>せっかくプログラムが迷路をうろうろ探索しているので、その探索の様子を可視化してみよう。</p>
<h4 id="アニメーション用ライブラリのロード">9. アニメーション用ライブラリのロード</h4>
<p>まず、アニメーション用のライブラリをインストール、ロードする。以下は上から数えて9つ目のセルになるはずだ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">!</span>pip install apng
<span class="im">from</span> apng <span class="im">import</span> APNG</code></pre></div>
<h4 id="アニメーション用のソルバ">10. アニメーション用のソルバ</h4>
<p>次に、アニメーション用の探索ルーチンを書く。ほとんど<code>solve</code>と同じだが、毎ステップの状態をファイルに保存する処理が追加されている。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> solve_anime(x, y, step, maze, files):
    <span class="cf">if</span> maze[x][y] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:
        <span class="cf">return</span>
    <span class="cf">if</span> <span class="bu">isinstance</span>(maze[x][y], <span class="bu">int</span>):
        <span class="cf">return</span>
    maze[x][y] <span class="op">=</span> step
    index <span class="op">=</span> <span class="bu">len</span>(files)
    filename <span class="op">=</span> <span class="st">&quot;file</span><span class="sc">%03d</span><span class="st">.png&quot;</span> <span class="op">%</span> index
    save_image(maze,filename)
    files.append(filename)
    solve_anime(x<span class="op">+</span><span class="dv">1</span>, y, step<span class="op">+</span><span class="dv">1</span>, maze, files)
    <span class="co"># 残りを埋めよ</span></code></pre></div>
<h4 id="アニメーションの保存">11. アニメーションの保存</h4>
<p>先程読み込んだ迷路データは「探索済み」になっているため、ファイルから読み込み直して、<code>solve_anime</code>を使って探索しなおそう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;maze.pickle&#39;</span>, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> f:
    maze <span class="op">=</span> pickle.load(f)
files <span class="op">=</span> []
solve_anime(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,maze,files)</code></pre></div>
<p>上記を実行することで、探索の様子が連番のファイル(file000.png, file001.png, …)に保存され、そのファイルリストが<code>files</code>に帰ってくる。</p>
<h4 id="アニメーションの表示">12. アニメーションの表示</h4>
<p>得られたファイルリストを使ってアニメーションを作成しよう。以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">APNG.from_files(files, delay<span class="op">=</span><span class="dv">50</span>).save(<span class="st">&quot;animation.png&quot;</span>)
IPython.display.Image(<span class="st">&quot;animation.png&quot;</span>)</code></pre></div>
<p>ここまで正しく組めていれば、探索の様子がアニメーションで表示されたはずである。</p>
<h2 id="余談エレファントな解法">余談：エレファントな解法</h2>
<p>チェス、将棋、囲碁、オセロといった「ゲーム」は、局面によって打てる「手」が決まっており、これを「合法手」と呼ぶ。何か「手」を打つと局面が変化し、また合法手も変化する。今、局面によって平均で4種類の合法手があり、勝負がつくまでに10手程度かかるゲームがあるとする。最終局面の数は4の10乗で、およそ100万通りである。もし勝負がつくまでに40手かかるとすると、4の40乗でおよそ一兆通りになる。このように、ゲームの状態数は、手の数に対して指数関数的に増えていく。このように、問題サイズに対して状態数が指数関数的に増えることを <strong>組み合わせ爆発</strong> と呼ぶ。組み合わせ爆発を題材にした、日本科学未来館の<a href="https://www.youtube.com/watch?v=Q4gTV4r0zRs">フカシギの数え方</a>という動画、通称「フカシギおねえさん」は面白いので是非一度見てみられたい。</p>
<p>一般に組み合わせ爆発が起きると計算機を使っても手も足もでないことが多いのだが、うまく「大きいけど有限」に問題を落とすことができると計算機で「読み切る」ことができる。その有名な例が四色問題であろう。四色問題とは「二次元の地図に対して、隣り合う領域を同じ色に塗らないという条件を満たしつつ全ての領域に色を塗るのに四色あれば足りるか」という命題である。簡単な地図を描くことで三色では足りないことがわかり、また六色あれば足りることの証明は容易である。五色で足りる証明(証明はかなり面倒だ)も提案されたが、四色で足りることの数学的な証明は長らくされなかった。四色問題が提起されてからおよそ100年後の1976年、アッペルとハーケンは、四色問題問題を「大きいが有限」の問題に帰着させ、その上でスパコンで力任せに「四色で足りる」ことを証明した。雑な言い方をすれば「この地図すべてを四色で塗ることができれば、いかなる地図も四色で塗ることができる」という「基礎地図(正確には不可避集合)」をすべてリストアップし、その「基礎地図」がすべて四色で塗り分けられることを示す、という方法である。</p>
<p>似たような「証明」に、「9×9の数独について、解が一意であるためには最低ヒントが17個必要である」という定理もある。これも、「すべての可能な数独の問題」に対して、それぞれに「すべての16ヒント問題」を作り、それが全て解が一意でないことをスパコンで力任せに確認することで証明された。このように「大きいが有限」の問題に帰着させて計算機で力任せに解いてしまうことを「エレファントな証明」と呼ぶ。数学の美しい証明を「エレガントな証明」と呼ぶことの対比である。</p>
<p>果たして「エレファントな証明」は人類を賢くしているのか？というのは難しい問題であり、現在もよく議論になる。例えばオセロも6×6マスまでは完全に解析されており(後手必勝である)、その知識を使えば、後手番なら絶対に負けない思考ルーチンを作ることができるのだが、果たしてそれは「思考」ルーチンといえるのだろうか？このような問題は、例えば<a href="https://ja.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E8%AA%9E%E3%81%AE%E9%83%A8%E5%B1%8B">中国語の部屋</a>という思考実験で問題提起されている。</p>
<p>私個人の意見としては、「エレファント」であろうと証明は証明だし、人類の知識を増やしたことは間違いないと考えている。ただし、それが「人類を賢くしたか」は別問題である。今後、「計算機が何か答えを出し、なぜかはわからないがそれが正しいように見える」ことが増えるであろう(天気予報が典型例だ)。このような「計算された知性」と人類はどう向き合うべきか、は難しい問題である。</p>
</article>
</body>
</html>
