# 計算量とアルゴリズム [(HTML)](https://kaityo256.github.io/python_zero/complexity/)

本稿で学ぶこと

* 計算のオーダー(ランダウ表記)
* フィボナッチとメモ化

## 計算量とは

計算量とは、計算機で何か問題を解くときにトータルで使う計算資源の量であるが、一般的には問題サイズを大きくしたときにどれだけ計算量が増えるかのスケーリングを表す。

TODO: O記法
TODO: 時間計算量、空間計算量

## アルゴリズムの工夫の例：メモ化

### ナイーブな再起実装

アルゴリズムの工夫により、計算量が圧倒的に下がることを見てみよう。まずはフィボナッチ数について考える。
フィボナッチ数とは、最初が0、次が1、それ以降は一つ前と二つ前の和で定義される値である。数式で書くと

$$
\begin{aligned}
F_0 &= 0 \\
F_1 &= 1 \\
F_n &= F_{n-1} + F_{n-2} \\
\end{aligned}
$$

この数列を順番に計算していくと、以下のようになる。

$$
0, 1, 1, 2, 3, 5, 8, 11, \cdots
$$

この数列をフィボナッチ数列、それぞれの数字をフィボナッチ数と呼ぶ。

さて、ある整数$n$が与えられた時、フィボナッチ数$F_n$を求めるプログラムを考えよう。
定義より、$F_n$とは、$F_{n-1}$と$F_{n-2}$の和である。$F_{n-1}$が0か1なら値が決まるが、そうでなければ
$F_{n-2}$と$F_{n-3}$の和である。こうして、次々と再帰的に処理を行う。

TODO: 上記の文章をrefine

この手続を素直に書くと以下のような再起プログラムになる。

```py
def fib(n):
    if n in (0, 1):
        return n
    return fib(n-1) + fib(n-2)
```

実際に計算させて見よう。例えば$F_{6}$は`fib(6)`で求めることができる。

```py
fib(6) #=> 8
```

このアルゴリズムでは、少し大きなインデックスのフィボナッチ数、たとえば`fib(30)`を計算すると少し待たされる。この計算時間を測定してみよう。Google Colabでは(正確にはJupyter Notebookでは)、`%time`をつけると実行時間を計測することができる。

```py
%time fib(30)
```

上記を実行すると、たとえば以下のような結果が得られる。

```sh
CPU times: user 494 ms, sys: 2 ms, total: 496 ms
Wall time: 498 ms
832040
```

たった30番目のフィボナッチ数を計算するのに、かなりかかっていることがわかるだろう。

### メモ化

先程のアルゴリズムは定義通り計算したわけだが、これはかなり無駄が多い。
実際に、6番目のフィボナッチ数$F_6$を求めるには、$F_5$と$F_4$が必要であり
$F_5$の値には$F_4$と$F_3$、$F_4$の値を求めるのに$F_3$と$F_2$・・・と計算していくため、
同じフィボナッチ数を何度も計算してしまう。まずはこの状況を図解してみよう。

同じノートブックの下の方に、二つのセルに分けて以下を入力して見よ。

```py
from graphviz import Digraph
  
def fib_graph(n, parent, nodes, g):
    index = len(nodes)
    nodes.append(index)
    if n == 1:
        g.node(str(index), str(n), color="red")
    else:
        g.node(str(index), str(n))

    if parent is not None:
        g.edge(str(index), str(parent))
    if n in (0, 1):
        return
    fib_graph(n-1, index, nodes, g)
    fib_graph(n-2, index, nodes, g)
```

```py
import IPython
g = Digraph(format="png")
fib_graph(6, None, [], g)
g.graph_attr.update(size="10,10")
g.render("test")
IPython.display.Image("test.png")
```

入力が終わったら実行してみよう。以下のようなグラフが表示されるはずである。

![fib/fib6.png](fig/fib6.png)

最終的に「0」か「1」に到達したところが終端であり、「1」の総数がフィボナッチ数の値である。この場合、グラフに「1」が8つあるので$F_6$は$1$となる。
他にも

```py
fib_graph(6, None, [], g)
```

の数字を変えて実行してみよ。たとえば「7」や「8」ではどうか。入力する数字に対して、グラフの「ノードの数」はどのように増えていくだろうか。

さて、同じフィボナッチ数の値を何度も計算してしまうのが無駄であったので、一度計算した値を覚えておき、再度必要になったらそれを使うことを考えよう。
同じノートブックの上の方に、以下のようなセルを入力せよ。

```py
def fib_memo(k, h):
    if k in (0, 1):
        return k
    if k in h:
        return h[k]
    h[k] = fib_memo(k-1, h) + fib_memo(k-2, h)
    return h[k]
```

入力が終わったら、その下のセルに以下のように入力し、実行せよ。

```py
%time fib_memo(30, {})
```

先程`fib(30)`を実行した場合と比べて実行時間が圧倒的に短くなったことをがわかるだろう。

TODO: 説明

### 線形アルゴリズム

さて、前述のアルゴリズムは二つとも再帰を用いたが、もっと素直に最初から順番にすべての値を求めるアルゴリズムが考えられる。
`fib_memo`を実行するセルの下あたりに、以下のプログラムを入力せよ。

```py
def fib_linear(n):
    if n in (0, 1):
        return n
    f1 = 0
    f2 = 1
    fn = 0
    for _ in range(n-1):
        fn = f1+f2
        f1 = f2
        f2 = fn
    return fn
```

入力が終わったら、以下のように実行してみよう。

```py
%time fib_linear(30)
```

ゆらぎはあるものの、先程のメモ化アルゴリズムより若干早いことがわかるだろう。

TODO: fib, fib_memo, fib_linearの計算オーダーの説明